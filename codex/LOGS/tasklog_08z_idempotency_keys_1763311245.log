OpenAI Codex v0.58.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5.1-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a8d8a-5a6e-7cb1-9fb0-52df623ac063
--------
user
Implement the functionality described in codex/TASKS/08z_idempotency_keys.yaml, then verify with any available tests.
ERROR: MCP client for `arxiv-mcp-server-gpt` failed to start: handshaking with MCP server failed: connection closed: initialize response

thinking
**Preparing to gather task instructions**
exec
bash -lc ls in /var/home/rick/Development/playlist-manager succeeded in 48ms:
AGENTS.md
apps
codex
codex.toml
docker-compose.yml
docs
dredd.server.yml
dredd.yml
env.json
Jackett
Jackett.Binaries.LinuxAMDx64.tar.gz
node_modules
openapi.dredd.yaml
openapi.yaml
package.json
packages
pnpm-lock.yaml
pnpm-workspace.yaml
README.md
schemas

thinking
**Opening codex task file**
exec
bash -lc 'ls codex/TASKS' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
00_repo_sanity_review.yaml
01a_spec_bootstrap.yaml
02a_prisma_init.yaml
02b_raw_migrations.yaml
02c_prisma_seeds.yaml
02d_db_indexes_bench.yaml
03a_dbpkg_singleton.yaml
03b_db_migration_ci_gate.yaml
03c_token_encryption_at_rest.yaml
04a_api_validation_wiring.yaml
04b_openapi_warning_silencer.yaml
04c_api_docs_ui.yaml
04d_config_feature_flags.yaml
05a_pif_validator.yaml
05b_file_exporters.yaml
05c_importers_file.yaml
06a_provider_interfaces.yaml
06b_spotify_impl.yaml
06c_deezer_impl.yaml
06d_tidal_impl.yaml

thinking
**Reading file 08z**
exec
bash -lc 'cat codex/TASKS/08z_idempotency_keys.yaml' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
id: 08z_idempotency_keys
title: Idempotency-Key for job-enqueue endpoints
branch: codex/08z_idempotency_keys
overview: >
  Support Idempotency-Key header on POST /exports/file and /jobs/migrate.
  Duplicate requests with the same key+fingerprint return the original JobRef.
acceptance:
  - Repeated POST with same Idempotency-Key returns identical job_id
  - Different body with same key returns 422 with error.type=idempotency_conflict
  - Keys expire after configurable TTL
artifacts_to_touch:
  - openapi.yaml (document header + 422 response)
  - apps/api/src/lib/idempotency.ts
  - apps/api/src/routes/exports.file.ts
  - apps/api/src/routes/jobs.migrate.ts
  - apps/api/src/dev/start.ts (plugin registration)
  - apps/api/src/config/env.ts (TTL)
steps:
  - Compute request fingerprint (method+path+normalized body)
  - Store mapping key→job_id in Redis or DB with TTL

thinking
**Preparing to plan multi-step implementation**
exec
bash -lc "sed -n '1,200p' apps/api/src/routes/exports.file.ts" in /var/home/rick/Development/playlist-manager exited 2 in 42ms:
sed: can't read apps/api/src/routes/exports.file.ts: No such file or directory

thinking
**Listing route directory contents**
exec
bash -lc 'ls apps/api/src/routes' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
active-playlist
artists
auth.providers.ts
docs.ts
exports
imports.file.ts
jobs
jobs.events.ts
_mockData.ts
playlists
register-handlers.ts
__tests__

thinking
**Checking for export files**
exec
bash -lc 'ls apps/api/src/routes/exports' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
file.post.ts

thinking
**Checking file for rename need**
exec
bash -lc "sed -n '1,200p' apps/api/src/routes/exports/file.post.ts" in /var/home/rick/Development/playlist-manager succeeded in 47ms:
import { FastifyReply, FastifyRequest } from 'fastify';
import { enqueue } from '../../lib/jobs/enqueue';
import { validateRequestBody } from '../../lib/openapi/validator';

type Body = {
  playlist_id: number;
  format: 'm3u' | 'xspf' | 'csv';
  variant?: 'lean' | 'verbose';
};

export default async function handler(
  request: FastifyRequest<{ Body: Body }>,
  reply: FastifyReply,
) {
  const rawContentType = request.headers['content-type'];
  const contentType = Array.isArray(rawContentType)
    ? rawContentType[0]
    : typeof rawContentType === 'string'
      ? rawContentType
      : undefined;

thinking
**Planning idempotency and migration routes**
exec
bash -lc 'ls apps/api/src/routes/jobs' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
[id].get.ts
migrate.post.ts

thinking
**Opening migration file**
exec
bash -lc "sed -n '1,200p' apps/api/src/routes/jobs/migrate.post.ts" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
import { FastifyReply, FastifyRequest } from 'fastify';
import { enqueue } from '../../lib/jobs/enqueue';
import { validateRequestBody } from '../../lib/openapi/validator';

type Body = {
  source_provider: 'spotify' | 'deezer' | 'tidal' | 'youtube';
  source_playlist_id: number;
  dest_provider: 'spotify' | 'deezer' | 'tidal' | 'youtube';
  dest_playlist_name?: string;
};

export default async function handler(
  request: FastifyRequest<{ Body: Body }>,
  reply: FastifyReply,
) {
  const rawContentType = request.headers['content-type'];
  const contentType = Array.isArray(rawContentType)
    ? rawContentType[0]
    : typeof rawContentType === 'string'
      ? rawContentType

thinking
**Inspecting libraries for idempotency**
exec
bash -lc 'ls apps/api/src/lib' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
crypto
db
idempotency.ts
jobs
oauth
openapi
problem.ts

thinking
**Opening idempotency file**
exec
bash -lc "sed -n '1,200p' apps/api/src/lib/idempotency.ts" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
type Entry = { fingerprint: string; jobId: string; expiresAt: number };
const STORE = new Map<string, Entry>();
const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);

function now() { return Date.now(); }
function sweep() {
  const t = now();
  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
}

export function remember(key: string, fingerprint: string, jobId: string) {
  sweep();
  STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
}

export function lookup(key: string): Entry | undefined {
  sweep();
  return STORE.get(key);
}

thinking
**Checking environment config for TTL**
exec
bash -lc "sed -n '1,200p' apps/api/src/config/env.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
import { z } from 'zod';

const EnvSchema = z.object({
  MASTER_KEY: z
    .string({
      required_error: 'MASTER_KEY env var is required',
    })
    .min(1),
});

export const env = EnvSchema.parse({
  MASTER_KEY: process.env.MASTER_KEY,
});

thinking
**Considering adding TTL to config**
exec
bash -lc "sed -n '1,200p' apps/api/src/dev/start.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
import Fastify from 'fastify';
import fastifyStatic from '@fastify/static';
import path from 'node:path';
import docsRoutes from '../routes/docs.js'; // ensure .ts resolves via tsx; .js is ok too
import authProviders from '../routes/auth.providers.js';
import { registerRouteHandlers } from '../routes/register-handlers.js';
import logging from '../plugins/logging.js';
import metrics from '../plugins/metrics.js';
import featureGuard from '../plugins/feature-guard.js';
import errorsPlugin from '../plugins/errors.js';
import jobEvents from '../routes/jobs.events.js';
import importsFile from '../routes/imports.file.js';

const app = Fastify({ logger: true });

await app.register(fastifyStatic, {
  root: path.join(process.cwd(), 'apps/api/public'),
  prefix: '/',
});


thinking
**Searching for idempotency plugin**
exec
bash -lc 'rg -n "idempotency" -n' in /var/home/rick/Development/playlist-manager succeeded in 55ms:
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:13:Implement the functionality described in codex/TASKS/08z_idempotency_keys.yaml, then verify with any available tests.
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:69:bash -lc 'cat codex/TASKS/08z_idempotency_keys.yaml' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:70:id: 08z_idempotency_keys
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:72:branch: codex/08z_idempotency_keys
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:78:  - Different body with same key returns 422 with error.type=idempotency_conflict
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:82:  - apps/api/src/lib/idempotency.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:146:**Planning idempotency and migration routes**
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:178:**Inspecting libraries for idempotency**
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:183:idempotency.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:190:**Opening idempotency file**
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:192:bash -lc "sed -n '1,200p' apps/api/src/lib/idempotency.ts" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:257:**Searching for idempotency plugin**
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:259:bash -lc 'rg -n "idempotency" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_08d_worker_jobs_migrate_1763310116.log:150:codex/LOGS/codex_run_2025-11-16_08-49-16.log:7:Tasks: 07a_routes_playlist_items_effective 07c_error_contracts 07b_route_exports_file 07d_sse_job_progress 08a_worker_jobs_gc 08b_worker_export_file 08c_route_jobs_migrate 08d_worker_jobs_migrate 08z_idempotency_keys
codex/LOGS/tasklog_08d_worker_jobs_migrate_1763310116.log:152:codex/LOGS/tasklog_07b_route_exports_file_1763303753.log:749:codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:558:codex/LOGS/codex_run_2025-11-16_08-49-16.log:7:Tasks: 07a_routes_playlist_items_effective 07c_error_contracts 07b_route_exports_file 07d_sse_job_progress 08a_worker_jobs_gc 08b_worker_export_file 08c_route_jobs_migrate 08d_worker_jobs_migrate 08z_idempotency_keys
codex/LOGS/tasklog_08d_worker_jobs_migrate_1763310116.log:153:codex/LOGS/tasklog_07b_route_exports_file_1763303753.log:750:codex/LOGS/codex_run_2025-11-16_08-49-16.log:7:Tasks: 07a_routes_playlist_items_effective 07c_error_contracts 07b_route_exports_file 07d_sse_job_progress 08a_worker_jobs_gc 08b_worker_export_file 08c_route_jobs_migrate 08d_worker_jobs_migrate 08z_idempotency_keys
codex/LOGS/tasklog_08d_worker_jobs_migrate_1763310116.log:154:codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:558:codex/LOGS/codex_run_2025-11-16_08-49-16.log:7:Tasks: 07a_routes_playlist_items_effective 07c_error_contracts 07b_route_exports_file 07d_sse_job_progress 08a_worker_jobs_gc 08b_worker_export_file 08c_route_jobs_migrate 08d_worker_jobs_migrate 08z_idempotency_keys
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:306:  → Enhance DB seed tests to cover deterministic data, playlist length, and idempotency (TDD red).
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:2755:  ✓ Enhance DB seed tests to cover deterministic data, playlist length, and idempotency (TDD red).
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:2858:I'm laying out a detailed plan to enhance seed.ts for deterministic upserts of users, artists, albums, recordings, and playlist items, ensuring transactional integrity, ordering, and process exit codes. I want to add a new playlist.json for ordered playlist seeding, revise seed-data JSON files with consistent MBIDs and other fields, and ensure idempotency by updating or removing playlist items to exactly match the spec while using Prisma transaction clients correctly.

thinking
**Locating test files**
exec
bash -lc 'ls apps/api/src/routes/__tests__' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
auth.providers.test.ts
docs.test.ts
imports.file.test.ts
jobs.events.test.ts
register-handlers.test.ts

thinking
**Searching for existing exports tests**
exec
bash -lc "rg -n \"\\/exports\\/file\" -n openapi.yaml" in /var/home/rick/Development/playlist-manager succeeded in 43ms:
519:  /exports/file:
exec
bash -lc "sed -n '519,640p' openapi.yaml" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
  /exports/file:
    post:
      summary: Export a playlist to file
      operationId: exports_enqueueFile
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [playlist_id, format]
              properties:
                playlist_id: { type: integer }
                format: { type: string, enum: [m3u, xspf, csv] }
                variant: { type: string, enum: [lean, verbose], default: lean }
            examples:
              csvLean:
                value:
                  playlist_id: 1
                  format: csv

thinking
**Checking specification for /jobs/migrate**
exec
bash -lc "rg -n \"jobs\\/migrate\" openapi.yaml" in /var/home/rick/Development/playlist-manager succeeded in 42ms:
264:  /jobs/migrate:
exec
bash -lc "sed -n '264,360p' openapi.yaml" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
  /jobs/migrate:
    post:
      summary: Migrate a playlist between providers
      operationId: jobs_requestMigration
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [source_provider, source_playlist_id, dest_provider]
              properties:
                source_provider: { type: string, enum: [spotify, deezer, tidal, youtube] }
                source_playlist_id: { type: integer }
                dest_provider: { type: string, enum: [spotify, deezer, tidal, youtube] }
                dest_playlist_name: { type: string }
            examples:
              basic:
                value:
                  source_provider: spotify

thinking
**Searching for 422 responses**
exec
bash -lc 'rg -n "422" openapi.yaml' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
176:        '422': { $ref: '#/components/responses/UnprocessableEntity' }
753:                details: { request_id: req_422body }

thinking
**Checking for 422 response definition**
exec
bash -lc "sed -n '640,820p' openapi.yaml" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
            default: '123e4567-e89b-12d3-a456-426614174000'
          examples:
            default:
              value: '123e4567-e89b-12d3-a456-426614174000'
          x-example: '123e4567-e89b-12d3-a456-426614174000'
        - in: query
          name: types
          schema:
            type: array
            items: { type: string, enum: [influences, influenced_by, collaborated_with, member_of, has_members] }
            uniqueItems: true
          style: form
          explode: false
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object

thinking
**Preparing idempotency documentation and implementation**
exec
bash -lc 'ls apps/api/src/lib/jobs' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
enqueue.ts
exec
bash -lc "sed -n '1,200p' apps/api/src/lib/jobs/enqueue.ts" in /var/home/rick/Development/playlist-manager succeeded in 49ms:
/**
 * Temporary enqueue stub for contract tests.
 * When API_FAKE_ENQUEUE=1, returns a deterministic id without touching Redis/queues.
 * Replace with real BullMQ wiring in worker tasks.
 */
export async function enqueue(_payload: unknown): Promise<{ id: number }> {
  if (process.env.API_FAKE_ENQUEUE === '1') {
    return { id: 999 };
  }
  throw new Error('enqueue not wired yet (set API_FAKE_ENQUEUE=1 for contract tests)');
}

thinking
**Searching for exports route tests**
exec
bash -lc "rg -n \"exports\\/file\" -n apps/api/src -g\"*.test.ts\"" in /var/home/rick/Development/playlist-manager exited 1 in 46ms:


thinking
**Checking for existing tests**
exec
bash -lc "sed -n '1,200p' apps/api/src/routes/__tests__/imports.file.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 48ms:
import fs from 'node:fs';
import path from 'node:path';
import fastify from 'fastify';
import { afterEach, describe, expect, it } from 'vitest';

import { validatePIF } from '@app/contracts';

import errorsPlugin from '../../plugins/errors';
import importsFile from '../imports.file';

const FIXTURES_DIR = path.resolve(
  process.cwd(),
  'packages/interop/test/importers/__fixtures__',
);

function loadFixture(name: string): string {
  return fs.readFileSync(path.join(FIXTURES_DIR, name), 'utf8');
}

describe('POST /imports/file', () => {

thinking
**Investigating test strategy for exports and jobs**
exec
bash -lc "sed -n '1,200p' apps/api/src/routes/register-handlers.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
import type { FastifyInstance, RouteShorthandOptions } from 'fastify';

export type RouteDefinition = {
  method: 'GET' | 'POST' | 'PUT' | 'DELETE';
  url: string;
  modulePath: string;
  exportName?: 'default' | 'handler';
  options?: RouteShorthandOptions;
};

const ROUTES: RouteDefinition[] = [
  { method: 'GET',    url: '/playlists',                     modulePath: './playlists/index.get.js' },
  { method: 'GET',    url: '/playlists/:id',                 modulePath: './playlists/[id].get.js' },
  { method: 'GET',    url: '/playlists/:id/items',           modulePath: './playlists/[id]/items.get.js' },
  { method: 'GET',    url: '/active-playlist',               modulePath: './active-playlist/index.get.js' },
  { method: 'PUT',    url: '/active-playlist',               modulePath: './active-playlist/index.put.js' },
  { method: 'POST',   url: '/active-playlist/items',         modulePath: './active-playlist/items/index.post.js' },
  { method: 'DELETE', url: '/active-playlist/items/:itemId', modulePath: './active-playlist/items/[itemId].delete.js' },
  { method: 'POST',   url: '/jobs/migrate',                  modulePath: './jobs/migrate.post.js' },
  { method: 'GET',    url: '/jobs/:id',                      modulePath: './jobs/[id].get.js' },

thinking
**Planning idempotency key integration**
exec
bash -lc "rg -n \"jobs\\/migrate\" -g\"*.test.ts\" -n" in /var/home/rick/Development/playlist-manager succeeded in 48ms:
apps/api/src/routes/__tests__/auth.providers.test.ts:102:    const migrateHandler = (await import('../jobs/migrate.post')).default;
codex/code/codex/08c_route_jobs_migrate/tests/migrate.route.test.ts:15:  const res = await request(app).post('/api/v1/jobs/migrate').send(DUMMY_PAYLOAD);
codex/code/codex/08c_route_jobs_migrate/tests/migrate.route.test.ts:23:    .post('/api/v1/jobs/migrate')

thinking
**Opening auth.providers.test file**
exec
bash -lc "sed -n '1,200p' apps/api/src/routes/__tests__/auth.providers.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
import { afterEach, describe, expect, it, vi } from 'vitest';

vi.mock('fastify-plugin', () => ({
  default: (fn: any) => fn,
  __esModule: true,
}));

type RequestDecoratorMap = Record<string, (...args: any[]) => unknown>;

function resetProviderEnv() {
  delete process.env.PROVIDERS_SPOTIFY_ENABLED;
  delete process.env.PROVIDERS_DEEZER_ENABLED;
  delete process.env.PROVIDERS_TIDAL_ENABLED;
  delete process.env.PROVIDERS_YOUTUBE_ENABLED;
}

function createStubApp() {
  const requestDecorators: RequestDecoratorMap = {};

  const app: any = {

thinking
**Checking feature guard plugin**
exec
bash -lc "sed -n '1,200p' apps/api/src/plugins/feature-guard.ts" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
import fp from 'fastify-plugin';
import type { FastifyRequest } from 'fastify';

import { isProviderEnabled, ProviderFlagName } from '../config/flags';
import { problem } from '../lib/problem';

export default fp(async (app) => {
  app.decorate('requireProvider', (name: ProviderFlagName) => {
    if (!isProviderEnabled(name)) {
      throw problem({
        status: 503,
        code: 'provider_disabled',
        message: `${name} provider is disabled`,
      });
    }
  });

  app.decorateRequest(
    'requireProvider',
    function (this: FastifyRequest, name: ProviderFlagName) {

thinking
**Planning idempotency plugin**
exec
bash -lc "sed -n '1,200p' apps/api/src/lib/problem.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
export type ProblemOptions = {
  status: number;
  code: string;
  message: string;
  details?: Record<string, unknown> | null;
};

export type ProblemBody = {
  type: string;
  code: string;
  message: string;
  details: Record<string, unknown> & { request_id: string | null };
};

export function problem(options: ProblemOptions): Error {
  const { status, code, message, details } = options;
  const err: any = new Error(message);
  err.statusCode = status;
  err.code = code;
  if (details !== undefined) {

thinking
**Checking error handling utilities**
exec
bash -lc "sed -n '1,200p' apps/api/src/plugins/errors.ts" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
import fp from 'fastify-plugin';
import type { FastifyRequest } from 'fastify';
import { nanoid } from 'nanoid';

import { toProblemBody } from '../lib/problem';

const DEFAULT_ERROR_CODES: Record<number, string> = {
  400: 'bad_request',
  401: 'unauthorized',
  403: 'forbidden',
  404: 'not_found',
  409: 'conflict',
  422: 'unprocessable_entity',
  429: 'rate_limited',
  503: 'service_unavailable',
};

function resolveRequestId(req: FastifyRequest): string {
  const existing = (req as any).requestId;
  if (typeof existing === 'string') {

thinking
**Checking for idempotency plugin**
exec
bash -lc 'ls apps/api/src/plugins' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
errors.ts
feature-guard.ts
logging.ts
metrics.ts
__tests__

thinking
**Investigating plugin creation and usage**
exec
bash -lc "rg -n \"remember\\(\" -n" in /var/home/rick/Development/playlist-manager succeeded in 53ms:
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:203:export function remember(key: string, fingerprint: string, jobId: string) {
apps/api/src/lib/idempotency.ts:11:export function remember(key: string, fingerprint: string, jobId: string) {

thinking
**Investigating fingerprint computation**
exec
bash -lc 'rg -n "stable" -n' in /var/home/rick/Development/playlist-manager succeeded in 51ms:
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:582:bash -lc 'rg -n "stable" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_08d_worker_jobs_migrate_1763310116.log:1370:I'm working through implementing `processMigrate` to read a playlist, run a simple ISRC-based matcher, write the playlist to the destination provider, and update the job status in the database. I’m defining types for migration reports and unresolved tracks, planning error handling by marking jobs failed on exceptions, and figuring out how to stub Prisma and provider functions for testing through mock job records and stubbed authentication. The goal is to make the pipeline coherent and testable while meeting expected report shape and status updates.
Jackett/README.md:767: 1. Install [Mono 5.10](http://www.mono-project.com/download/#download-lin) or better (using the latest stable release is recommended)
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:7242:I'm planning to write worker tests using `vi.mock` to stub progress publishing functions, ensuring mocking happens before imports for TypeScript compatibility. I want to test progress reporting behavior like clamping percent values and default statuses, and also add optional throttling support to `createProgressReporter` to make update cadence testable and deterministic. I'll update types and implementation accordingly.
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:300:I'm refining the cross-platform fixture cleanup using a Node script embedded in package.json and planning detailed tests for both replay and record modes. I’m focusing on stable fixture key naming based on HTTP method and sanitized URLs, deciding to skip request body hashing for now to keep it simple. I’m also considering how to dynamically read environment variables during tests to avoid stale mode values, designing tests that confirm fetch is stubbed correctly in both modes, and ensuring helpful errors appear if fixture files are missing.
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:2105:-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:2106:+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:2118:     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:2121:-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:2122:+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:2384:     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:2387:-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:2388:+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:2663:     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:2666:-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:2667:+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:2929:     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:2932:-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:2933:+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:3220:     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",

thinking
**Examining idempotency storage and tests**
exec
bash -lc 'ls apps/api/src/plugins/__tests__' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
errors.test.ts

thinking
**Checking plugin testing style**
exec
bash -lc "sed -n '1,200p' apps/api/src/plugins/__tests__/errors.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
import fastify, { FastifyInstance } from 'fastify';
import { describe, expect, it } from 'vitest';

import errorsPlugin from '../errors';

async function buildApp(registerRoutes?: (app: FastifyInstance) => Promise<void> | void) {
  const app = fastify({ logger: false });
  await app.register(errorsPlugin);
  if (registerRoutes) {
    await registerRoutes(app);
  }
  await app.ready();
  return app;
}

describe('errors plugin', () => {
  it('echoes the x-request-id header in error responses', async () => {
    const app = await buildApp((instance) => {
      instance.get('/echo-request-id', async () => {
        const error = new Error('boom');

thinking
**Considering idempotency plugin design**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
{
  "name": "playlist-manager",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "packageManager": "pnpm@9.12.3",
  "engines": {
    "node": ">=18.18"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "lint:api": "redocly lint openapi.yaml --extends recommended",
    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    "mock:api": "prism mock openapi.yaml",
    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",
    "contract:test": "schemathesis run openapi.yaml --checks all --hypothesis-deadline=1000",
    "prisma:generate": "pnpm -F @app/db exec prisma generate",

thinking
**Planning deterministic stringify and TTL config**
exec
bash -lc "rg -n \"env\\.\" -n apps/api/src -g\"*.ts\"" in /var/home/rick/Development/playlist-manager succeeded in 46ms:
apps/api/src/config/env.ts:12:  MASTER_KEY: process.env.MASTER_KEY,
apps/api/src/config/flags.ts:8:    spotify: bool(process.env.PROVIDERS_SPOTIFY_ENABLED, true),
apps/api/src/config/flags.ts:9:    deezer:  bool(process.env.PROVIDERS_DEEZER_ENABLED, false),
apps/api/src/config/flags.ts:10:    tidal:   bool(process.env.PROVIDERS_TIDAL_ENABLED, false),
apps/api/src/config/flags.ts:11:    youtube: bool(process.env.PROVIDERS_YOUTUBE_ENABLED, false)
apps/api/src/plugins/logging.ts:5:  const logger = pino({ level: process.env.LOG_LEVEL ?? 'info' });
apps/api/src/routes/__tests__/auth.providers.test.ts:11:  delete process.env.PROVIDERS_SPOTIFY_ENABLED;
apps/api/src/routes/__tests__/auth.providers.test.ts:12:  delete process.env.PROVIDERS_DEEZER_ENABLED;
apps/api/src/routes/__tests__/auth.providers.test.ts:13:  delete process.env.PROVIDERS_TIDAL_ENABLED;
apps/api/src/routes/__tests__/auth.providers.test.ts:14:  delete process.env.PROVIDERS_YOUTUBE_ENABLED;
apps/api/src/routes/__tests__/auth.providers.test.ts:72:    process.env.PROVIDERS_SPOTIFY_ENABLED = 'false';
apps/api/src/routes/__tests__/auth.providers.test.ts:73:    process.env.PROVIDERS_DEEZER_ENABLED = 'true';
apps/api/src/routes/__tests__/auth.providers.test.ts:97:    process.env.PROVIDERS_SPOTIFY_ENABLED = 'false';
apps/api/src/routes/__tests__/auth.providers.test.ts:98:    process.env.PROVIDERS_DEEZER_ENABLED = 'true';
apps/api/src/dev/start.ts:33:const port = Number(process.env.API_PORT ?? 3101);
apps/api/src/dev/ensure-api-dev.ts:30:    host = process.env.API_HOST ?? '0.0.0.0',
apps/api/src/dev/ensure-api-dev.ts:31:    port = Number.parseInt(process.env.API_PORT ?? '3101', 10),
apps/api/src/lib/idempotency.ts:3:const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
apps/api/src/lib/jobs/enqueue.ts:7:  if (process.env.API_FAKE_ENQUEUE === '1') {
apps/api/src/lib/crypto/__tests__/keystore.test.ts:22:    process.env.MASTER_KEY = masterKey;

thinking
**Planning environment config and idempotency**
exec
bash -lc 'rg -n "fingerprint" -n' in /var/home/rick/Development/playlist-manager succeeded in 59ms:
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:75:  Duplicate requests with the same key+fingerprint return the original JobRef.
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:88:  - Compute request fingerprint (method+path+normalized body)
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:193:type Entry = { fingerprint: string; jobId: string; expiresAt: number };
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:203:export function remember(key: string, fingerprint: string, jobId: string) {
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:205:  STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:576:codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:203:export function remember(key: string, fingerprint: string, jobId: string) {
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:577:apps/api/src/lib/idempotency.ts:11:export function remember(key: string, fingerprint: string, jobId: string) {
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:580:**Investigating fingerprint computation**
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:688:bash -lc 'rg -n "fingerprint" -n' in /var/home/rick/Development/playlist-manager
apps/api/src/lib/idempotency.ts:1:type Entry = { fingerprint: string; jobId: string; expiresAt: number };
apps/api/src/lib/idempotency.ts:11:export function remember(key: string, fingerprint: string, jobId: string) {
apps/api/src/lib/idempotency.ts:13:  STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
codex/TASKS/08z_idempotency_keys.yaml:6:  Duplicate requests with the same key+fingerprint return the original JobRef.
codex/TASKS/08z_idempotency_keys.yaml:19:  - Compute request fingerprint (method+path+normalized body)
codex/TASKS/08z_idempotency_keys.yaml:21:  - Return prior JobRef if present; enforce conflict on mismatched fingerprint
codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:41588:- Implemented libsodium-style sealed-box keystore with key fingerprinting and tamper detection (`packages/db/src/encryption/crypto.ts:24`, `packages/db/src/encryption/crypto.ts:102`), re-exported for API use (`apps/api/src/lib/crypto/keystore.ts:1`), and validated env loading (`apps/api/src/config/env.ts:1`).
codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:42339:- Implemented libsodium-style sealed-box keystore with key fingerprinting and tamper detection (`packages/db/src/encryption/crypto.ts:24`, `packages/db/src/encryption/crypto.ts:102`), re-exported for API use (`apps/api/src/lib/crypto/keystore.ts:1`), and validated env loading (`apps/api/src/config/env.ts:1`).

thinking
**Planning test-driven combination design**
exec
bash -lc "sed -n '1,200p' apps/api/src/routes/__tests__/jobs.events.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 42ms:
import { PassThrough } from 'node:stream';
import { afterEach, describe, expect, it, vi } from 'vitest';

import jobEvents from '../jobs.events';
import {
  publishJobCompletion,
  publishJobProgress,
  resetJobProgressBus,
} from '@app/interop/jobs/progress';

describe('GET /jobs/:id/events', () => {
  afterEach(() => {
    resetJobProgressBus();
    vi.useRealTimers();
  });

  it('streams job progress updates through SSE', async () => {
    vi.useFakeTimers();
    const handler = await registerHandler();
    const harness = createSseHarness(7001);

thinking
**Checking existing test setup**
exec
bash -lc "sed -n '1,200p' apps/api/src/routes/__tests__/register-handlers.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 45ms:
import fastify from 'fastify';
import { describe, it, expect } from 'vitest';

import errorsPlugin from '../../plugins/errors';
import { registerRouteHandlers } from '../register-handlers';

describe('registerRouteHandlers', () => {
  async function buildApp() {
    const app = fastify({ logger: false });
    await app.register(errorsPlugin);
    await registerRouteHandlers(app);
    await app.ready();
    return app;
  }

  it('registers playlist routes with successful response', async () => {
    const app = await buildApp();

    try {
      const response = await app.inject({ method: 'GET', url: '/playlists' });

thinking
**Exploring export routes and planning plugin**
exec
bash -lc "sed -n '1,200p' apps/api/src/lib/openapi/validator.ts" in /var/home/rick/Development/playlist-manager succeeded in 42ms:
import { readFile } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { problem } from '../problem.js';

type HttpMethod = 'get' | 'post' | 'put' | 'delete' | 'patch' | 'options' | 'head';

type ReferenceObject = { $ref: string };

type SchemaObject = {
  type?: string | string[];
  required?: string[];
  properties?: Record<string, Schema>;
  items?: Schema;
  enum?: unknown[];
  oneOf?: Schema[];
  anyOf?: Schema[];
  allOf?: Schema[];
  not?: Schema;

thinking
**Planning idempotency plugin**
exec
bash -lc "sed -n '1,200p' apps/api/src/config/flags.ts" in /var/home/rick/Development/playlist-manager succeeded in 45ms:
export type ProviderFlagName = 'spotify' | 'deezer' | 'tidal' | 'youtube';

const bool = (v: string | undefined, d = false) =>
  v ? ['1','true','yes','on'].includes(v.toLowerCase()) : d;

export const flags: { providers: Record<ProviderFlagName, boolean> } = {
  providers: {
    spotify: bool(process.env.PROVIDERS_SPOTIFY_ENABLED, true),
    deezer:  bool(process.env.PROVIDERS_DEEZER_ENABLED, false),
    tidal:   bool(process.env.PROVIDERS_TIDAL_ENABLED, false),
    youtube: bool(process.env.PROVIDERS_YOUTUBE_ENABLED, false)
  }
};

export function isProviderEnabled(name: ProviderFlagName): boolean {
  return !!flags.providers[name];
}

export function getEnabledProviders(): ProviderFlagName[] {
  return (Object.entries(flags.providers) as Array<[ProviderFlagName, boolean]>)

thinking
**Checking env usage in keystore**
exec
bash -lc "sed -n '1,200p' apps/api/src/lib/crypto/keystore.ts" in /var/home/rick/Development/playlist-manager succeeded in 46ms:
export {
  createKeystore,
  getSealedSecretKeyId,
  isSealedSecret,
  KeystoreError,
  type CreateKeystoreOptions,
  type Keystore,
} from '../../../../packages/db/src/encryption';

thinking
**Planning idempotency plugin and config updates**

I’m outlining how to build a plugin for handling idempotency keyed requests, including request decoration, fingerprinting, and TTL management. I’m also figuring out how to extend the environment config schema to support an idempotency TTL with validation, and considering how to hook this all into existing routes and tests. Let’s explore these integration details carefully!
exec
bash -lc 'rg -n "IDEMPOTENCY" -n' in /var/home/rick/Development/playlist-manager succeeded in 52ms:
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:195:const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:681:apps/api/src/lib/idempotency.ts:3:const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:825:bash -lc 'rg -n "IDEMPOTENCY" -n' in /var/home/rick/Development/playlist-manager
apps/api/src/lib/idempotency.ts:3:const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);

thinking
**Designing request fingerprint computation**

I’m working through how to consistently compute a request fingerprint from the method, path, and normalized body—making sure the body is stably serialized with sorted keys and undefined keys omitted. I’m also considering idempotency store concerns like TTL and whether to expose store clearing for tests, leaning toward keeping tests isolated by using unique keys rather than clearing. Next, I want to ensure the fingerprint integrates smoothly with route handling logic and job ID storage.
exec
bash -lc 'rg -n "JobRef" -n openapi.yaml' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
292:              schema: { $ref: '#/components/schemas/JobRef' }
545:              schema: { $ref: '#/components/schemas/JobRef' }
984:    JobRef:
exec
bash -lc "sed -n '920,1030p' openapi.yaml" in /var/home/rick/Development/playlist-manager succeeded in 42ms:
      type: object
      properties:
        data:
          type: array
          items: { $ref: '#/components/schemas/PlaylistItemEffective' }
        next_cursor:
          type:
            - string
            - 'null'

    PlaylistItemEffective:
      type: object
      required: [id, position, title, artists]
      properties:
        id: { type: integer }
        position:
          type:
            - integer
            - 'null'
        title: { type: string }

thinking
**Planning idempotency TTL tests and route integration**

I’m mapping out how to adjust the idempotency store to use numeric job IDs and ensure TTL is configurable and tested, including adding unit tests for expiration. I’m considering test strategies for route handlers involving idempotency keys, mocking enqueue calls, and handling request validation with necessary plugins or stubs. There’s complexity around spec updates and TDD ordering, so I’m organizing a multi-step plan to update spec, add tests (unit and route-level), implement, then verify with full test runs before committing.
exec
bash -lc 'cat vitest.config.ts' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { defineConfig } from 'vitest/config';

const rootDir = path.dirname(fileURLToPath(import.meta.url));

export default defineConfig({
  resolve: {
    alias: {
      '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
      '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
      '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
      '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
      '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
      '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),
      '@app/providers-youtube': path.resolve(rootDir, 'packages/providers/youtube/src/index.ts'),
      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
      supertest: path.resolve(rootDir, 'codex/support/supertest.ts'),

thinking
**Examining test setup and plugin registration**
exec
bash -lc "sed -n '1,200p' apps/api/src/dev/ensure-api-dev.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import { spawn } from 'node:child_process';
import type { ChildProcess } from 'node:child_process';
import net from 'node:net';
import process from 'node:process';

export type EnsureApiDevOptions = {
  host?: string;
  port?: number;
  spawnServer?: () => ChildProcess | Promise<ChildProcess>;
  logger?: Pick<typeof console, 'info' | 'warn' | 'error'>;
};

export type EnsureApiDevResult =
  | {
      state: 'spawned';
      child: ChildProcess;
      wait: Promise<void>;
      release: () => void;
    }
  | {

thinking
**Designing idempotency helpers and error handling**

I'm mapping out helper functions for idempotency key management, fingerprint computation, job lookup, and conflict error throwing, while considering where to parse headers and how to integrate with routing and tests. I'll also look into updating the OpenAPI spec to properly document the 422 idempotency conflict response with precise error codes and examples.
exec
bash -lc 'rg -n "UnprocessableEntity" openapi.yaml' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
176:        '422': { $ref: '#/components/responses/UnprocessableEntity' }
741:    UnprocessableEntity:

thinking
**Checking code near line 176**
exec
bash -lc "sed -n '150,210p' openapi.yaml" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
                      - id: 101
                        position: 1
                        title: "Losing My Religion"
                        artists: "R.E.M."
                        album: "Out of Time"
                        duration_ms: 269000
                        isrc: "USWB19902945"
                        recording_id: 5551
                        mb_recording_id: "b8d0d7c0-8e1c-4b34-8bc3-38d78a0c2b1f"
                        mb_release_id: "b7a6d2e4-1c77-4a9f-9d5b-0c3b2ea0f4a1"
                        provider_track_id: "3urbQpVxWn"
                      - id: 102
                        position: 2
                        title: "Hurt"
                        artists: "Nine Inch Nails"
                        album: "The Downward Spiral"
                        duration_ms: 371000
                        isrc: "USIR19400383"
                        recording_id: 5552
                        mb_recording_id: "f2d9f7d3-7a61-485f-9b1e-2f4d8b3b7d1a"

thinking
**Evaluating idempotency conflict handling**
exec
bash -lc 'rg -n "idempot" -n -g"*.ts"' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
apps/api/src/routes/__tests__/register-handlers.test.ts:49:  it('treats artist unfollow as idempotent', async () => {
packages/db/test/token-rotation.test.ts:72:  it('is idempotent when run multiple times', () => {

thinking
**Analyzing plugin design and test strategy**

I’m figuring out how to build and register a new idempotency plugin for Fastify that adds request methods to handle idempotency keys and job deduplication, while aligning with the task’s requirement to register this plugin in the server startup. I’m also outlining a solid plan to add spec updates, write failing tests covering idempotency behavior on key routes, implement the core logic in the plugin and library, and then run the tests—following a test-driven approach throughout.
Plan update
  • Extend OpenAPI spec for Idempotency-Key header + 422 response on export/migrate endpoints.
  • Add failing tests covering repeated requests/conflicts (routes) and TTL behavior for the idempotency store.
  • Implement idempotency fingerprinting/store logic, plugin + env config, route wiring, and register the plugin.
  • Run the relevant test suite(s) and prepare the commit.

thinking
**Designing OpenAPI idempotency updates**

I’m working through how to update the OpenAPI spec to add an optional Idempotency-Key header and a new 422 response component for idempotency conflicts. I plan to insert the parameters and responses into the `/jobs/migrate` and `/exports/file` POST operations, carefully matching existing formatting and inserting after operationId using apply_patch. I’m also defining the key’s length, TTL, and detailed descriptions while considering how to integrate the new component cleanly.
file update
M /var/home/rick/Development/playlist-manager/openapi.yaml
@@ -267,2 +267,14 @@
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
@@ -299,2 +311,3 @@
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M openapi.yaml
file update:
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..0827138f029c9f60703dfb62866256eeb32e4e7a
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:

file update:
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..0827138f029c9f60703dfb62866256eeb32e4e7a
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:


thinking
**Adding 422 response to exports/file**
file update
M /var/home/rick/Development/playlist-manager/openapi.yaml
@@ -535,2 +535,14 @@
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
@@ -564,2 +576,3 @@
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M openapi.yaml
file update:
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..022def4591910f01305e27f21840d696ac1f07da
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:

file update:
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..022def4591910f01305e27f21840d696ac1f07da
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:


thinking
**Adding IdempotencyConflict response component**
file update
M /var/home/rick/Development/playlist-manager/openapi.yaml
@@ -766,2 +766,15 @@
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M openapi.yaml
file update:
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Updating plan status**
Plan update
  ✓ Extend OpenAPI spec for Idempotency-Key header + 422 response on export/migrate endpoints.
  → Add failing tests covering repeated requests/conflicts (routes) and TTL behavior for the idempotency store.
  • Implement idempotency fingerprinting/store logic, plugin + env config, route wiring, and register the plugin.
  • Run the relevant test suite(s) and prepare the commit.
file update:
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:





thinking
**Designing idempotency tests with TDD challenges**

I'm planning tests for idempotency that call route handlers directly and use mocks for dependencies like job enqueueing. Since the plugin for idempotency doesn’t exist yet, I’m figuring out how to write failing tests now without causing compile errors—considering stubs or skipping plugin registration in tests to keep TDD consistent while ensuring tests anticipate the future plugin integration.
thinking
**Evaluating plugin integration and test strategy**

I'm weighing whether to create a minimal plugin stub now to satisfy test imports or postpone plugin creation until implementation, while designing tests that stub necessary request properties to avoid dependency on the plugin. I’m considering an approach where route logic uses helper functions so tests remain independent of the plugin, which we’ll register later for production behavior, keeping TDD consistent and manageable.
thinking
**Designing and structuring route tests with mocks**

I'm sketching how to build route tests that create fresh request and reply objects per call, mock the async enqueue function properly, and verify idempotency behavior like repeated requests returning the same job, or rejecting with errors on conflicting payloads. I’m also considering how to isolate tests to avoid cross-contamination, handle environment-dependent TTLs, and gracefully manage mock responses to ensure meaningful test failures without unintended runtime errors.
thinking
**Planning detailed idempotency route and library tests**

I'm finalizing test plans for various idempotency scenarios on `/exports/file` and `/jobs/migrate` routes, including repeated requests returning the same job ID and conflicts causing errors. I’ll mock `enqueue` responses carefully to catch unexpected calls, stub necessary request details like `requireProvider`, and use unique keys per test to avoid interference. I’m also preparing to add library tests for TTL expiry and fingerprint normalization, making sure tests will cover important edge cases for robust idempotency behavior.
file update
A /var/home/rick/Development/playlist-manager/apps/api/src/routes/__tests__/idempotency.test.ts
import { afterEach, describe, expect, it, vi } from 'vitest';

vi.mock('../../lib/jobs/enqueue', () => ({
  enqueue: vi.fn(),
}));

import { enqueue } from '../../lib/jobs/enqueue';
import exportsFileHandler from '../exports/file.post';
import jobsMigrateHandler from '../jobs/migrate.post';

const enqueueMock = vi.mocked(enqueue);

describe('POST /exports/file idempotency', () => {
  afterEach(() => {
    enqueueMock.mockReset();
  });

  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });

    const firstReply = createReply();
    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);

    expect(firstReply.status).toHaveBeenCalledWith(202);
    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
    expect(enqueueMock).toHaveBeenCalledTimes(1);

    const secondReply = createReply();
    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);

    expect(secondReply.status).toHaveBeenCalledWith(202);
    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
    expect(enqueueMock).toHaveBeenCalledTimes(1);
  });
});

describe('POST /jobs/migrate idempotency', () => {
  afterEach(() => {
    enqueueMock.mockReset();
  });

  it('returns the original job when the payload is repeated', async () => {
    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });

    const firstReply = createReply();
    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });

    const secondReply = createReply();
    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
    expect(enqueueMock).toHaveBeenCalledTimes(1);
  });

  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
    enqueueMock.mockResolvedValueOnce({ id: 8811 });

    const firstReply = createReply();
    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });

    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
    const secondReply = createReply();

    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
      statusCode: 422,
      code: 'idempotency_conflict',
    });

    expect(enqueueMock).toHaveBeenCalledTimes(1);
    expect(secondReply.send).not.toHaveBeenCalled();
  });
});

function createReply() {
  return {
    status: vi.fn().mockReturnThis(),
    send: vi.fn().mockReturnThis(),
  };
}

function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
  return {
    body: {
      playlist_id: 77,
      format: 'csv',
      variant: 'lean',
      ...overrides,
    },
    headers: {
      'content-type': 'application/json',
      'idempotency-key': key,
    },
  };
}

function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
  return {
    body: {
      source_provider: 'spotify',
      source_playlist_id: 10,
      dest_provider: 'spotify',
      dest_playlist_name: 'Mirror copy',
      ...overrides,
    },
    headers: {
      'content-type': 'application/json',
      'idempotency-key': key,
    },
    requireProvider: vi.fn(),
  };
}
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
A apps/api/src/routes/__tests__/idempotency.test.ts
file update:
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:



thinking
**Ensuring test reliability and preparing idempotency tests**

I’m sorting out TypeScript typings for mocks and confirming test resets to avoid interference. I’m also planning TTL and fingerprint tests for idempotency, realizing I need to add a stub `fingerprintRequest` export now so tests compile—even though actual logic will come later—allowing me to write failing tests first and follow TDD properly.
thinking
**Planning environment setup and type handling for TTL tests**

I’m figuring out how to manage environment variables and module resets so TTL tests see the right config, while juggling type mismatches around job IDs—considering whether to cast in tests or update types early—and deciding to add stub exports alongside new tests to keep TypeScript happy without implementing logic yet.
file update
A /var/home/rick/Development/playlist-manager/apps/api/src/lib/__tests__/idempotency.test.ts
import { afterEach, describe, expect, it, vi } from 'vitest';

describe('idempotency store', () => {
  afterEach(() => {
    vi.resetModules();
    vi.useRealTimers();
    delete process.env.IDEMPOTENCY_TTL_SECONDS;
  });

  it('expires remembered keys after the configured TTL', async () => {
    vi.useFakeTimers();
    process.env.IDEMPOTENCY_TTL_SECONDS = '1';

    const { remember, lookup } = await import('../idempotency');

    remember('ttl-key', 'fingerprint-a', 77 as any);
    expect(lookup('ttl-key')?.jobId).toBe(77);

    vi.advanceTimersByTime(1000);
    expect(lookup('ttl-key')).toBeUndefined();
  });

  it('computes identical fingerprints for the same payload regardless of key order', async () => {
    const { fingerprintRequest } = await import('../idempotency');

    const first = fingerprintRequest({
      method: 'POST',
      path: '/exports/file',
      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
    });

    const second = fingerprintRequest({
      method: 'post',
      path: '/exports/file',
      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
    });

    const differentPath = fingerprintRequest({
      method: 'POST',
      path: '/jobs/migrate',
      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
    });

    expect(first).toBe(second);
    expect(differentPath).not.toBe(first);
  });
});
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
A apps/api/src/lib/__tests__/idempotency.test.ts
file update:
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Adding a basic stub for fingerprintRequest**
file update
M /var/home/rick/Development/playlist-manager/apps/api/src/lib/idempotency.ts
@@ -19 +19,5 @@
 }
+
+export function fingerprintRequest(input: { method: string; path: string; body: unknown }): string {
+  return JSON.stringify(input);
+}
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M apps/api/src/lib/idempotency.ts
file update:
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..50fda2e4bc3c10fb19404cb1f3e1d612f2b1e4a7
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -17,3 +17,7 @@
   sweep();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: { method: string; path: string; body: unknown }): string {
+  return JSON.stringify(input);
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..50fda2e4bc3c10fb19404cb1f3e1d612f2b1e4a7
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -17,3 +17,7 @@
   sweep();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: { method: string; path: string; body: unknown }): string {
+  return JSON.stringify(input);
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Reviewing test setup and typings**

I'm sorting out test details around TTL and fingerprintRequest, checking TypeScript type compatibility and module import/reset logic. There's quite a bit to ensure regarding timers, environment variables, module caching, and store clearing between tests. I also want to confirm that mocks, stubs, and request typings are properly set before moving from Step 2 tests to Step 3 implementation. It looks like running tests now might be optional but could help verify expected failures.
Plan update
  ✓ Extend OpenAPI spec for Idempotency-Key header + 422 response on export/migrate endpoints.
  ✓ Add failing tests covering repeated requests/conflicts (routes) and TTL behavior for the idempotency store.
  → Implement idempotency fingerprinting/store logic, plugin + env config, route wiring, and register the plugin.
  • Run the relevant test suite(s) and prepare the commit.
file update:
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..50fda2e4bc3c10fb19404cb1f3e1d612f2b1e4a7
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -17,3 +17,7 @@
   sweep();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: { method: string; path: string; body: unknown }): string {
+  return JSON.stringify(input);
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:




thinking
**Implementing idempotency with TTL and plugin**
thinking
**Standardizing idempotency key parsing and normalization**

I’m designing shared helper functions to parse and normalize the `Idempotency-Key` header consistently between plugin and route code. The library will export `normalizeIdempotencyKey` to trim and process the raw header value, handling arrays and enforcing sane defaults. The plugin will import this to expose a `getIdempotencyKey` method on requests without causing recursive calls. Routes will rely on a `resolveRequestIdempotencyKey` helper that prefers the plugin method if present but falls back to header parsing, making testing easier by not strictly requiring the plugin. I’m also refining JSON normalization for request fingerprinting to ensure deterministic sorting and skipping of `undefined` fields, so identical requests produce matching fingerprints regardless of key order. This foundation will keep idempotency logic consistent and reusable across the codebase.
thinking
**Finalizing TTL and fingerprint improvements**

I’m updating the lookup function to return the full entry with a typed job ID, adjusting tests to expect this change, and ensuring the fingerprinting logic correctly normalizes JSON with sorted keys and treats undefined top-level bodies as null. I’m also handling header key casing safely, confirming plugins register properly on server start, and verifying tests provide proper headers and reset mocks as needed for consistent idempotency behavior. This wraps up key integration points around TTL, request normalization, and plugin registration to make everything robust and test-friendly.
file update
M /var/home/rick/Development/playlist-manager/apps/api/src/config/env.ts
@@ -8,2 +8,7 @@
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+  .int()
+    .positive()
+    .default(15 * 60),
 });
@@ -12,2 +17,3 @@
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
apply_patch(auto_approved=true) exited 0 in 42ms:
Success. Updated the following files:
M apps/api/src/config/env.ts
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..2cbcf1e2d4be6af08f827f3514d3f31000057e48
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+  .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..50fda2e4bc3c10fb19404cb1f3e1d612f2b1e4a7
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -17,3 +17,7 @@
   sweep();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: { method: string; path: string; body: unknown }): string {
+  return JSON.stringify(input);
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..2cbcf1e2d4be6af08f827f3514d3f31000057e48
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+  .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..50fda2e4bc3c10fb19404cb1f3e1d612f2b1e4a7
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -17,3 +17,7 @@
   sweep();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: { method: string; path: string; body: unknown }): string {
+  return JSON.stringify(input);
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Fixing method chaining indentation**
file update
M /var/home/rick/Development/playlist-manager/apps/api/src/config/env.ts
@@ -10,3 +10,3 @@
     .number()
-  .int()
+    .int()
     .positive()
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M apps/api/src/config/env.ts
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..50fda2e4bc3c10fb19404cb1f3e1d612f2b1e4a7
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -17,3 +17,7 @@
   sweep();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: { method: string; path: string; body: unknown }): string {
+  return JSON.stringify(input);
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..50fda2e4bc3c10fb19404cb1f3e1d612f2b1e4a7
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -17,3 +17,7 @@
   sweep();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: { method: string; path: string; body: unknown }): string {
+  return JSON.stringify(input);
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Planning full rewrite of idempotency module**

I'm preparing to replace the entire `apps/api/src/lib/idempotency.ts` file with a new implementation that refines how idempotency keys are normalized, stored, and resolved from request headers or methods. The new logic carefully handles header casing, supports optional helper methods, and enforces consistent key trimming and fingerprint checks—all aimed at better type safety and functionality. I'll apply the replacement via patch since the changes are extensive.
file update
D /var/home/rick/Development/playlist-manager/apps/api/src/lib/idempotency.ts
type Entry = { fingerprint: string; jobId: string; expiresAt: number };
const STORE = new Map<string, Entry>();
const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);

function now() { return Date.now(); }
function sweep() {
  const t = now();
  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
}

export function remember(key: string, fingerprint: string, jobId: string) {
  sweep();
  STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
}

export function lookup(key: string): Entry | undefined {
  sweep();
  return STORE.get(key);
}

export function fingerprintRequest(input: { method: string; path: string; body: unknown }): string {
  return JSON.stringify(input);
}
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
D apps/api/src/lib/idempotency.ts
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
deleted file mode 100644
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..0000000000000000000000000000000000000000
--- a/apps/api/src/lib/idempotency.ts
+++ /dev/null
@@ -1,19 +0,0 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
-const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
-
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
-}
-
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
-  STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
-}
-
-export function lookup(key: string): Entry | undefined {
-  sweep();
-  return STORE.get(key);
-}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
deleted file mode 100644
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..0000000000000000000000000000000000000000
--- a/apps/api/src/lib/idempotency.ts
+++ /dev/null
@@ -1,19 +0,0 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
-const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
-
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
-}
-
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
-  STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
-}
-
-export function lookup(key: string): Entry | undefined {
-  sweep();
-  return STORE.get(key);
-}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Adding new idempotency library file**
file update
A /var/home/rick/Development/playlist-manager/apps/api/src/lib/idempotency.ts
import { env } from '../config/env';
import { problem } from './problem';

type Entry = { fingerprint: string; jobId: number; expiresAt: number };
type FingerprintInput = { method: string; path: string; body: unknown };
type RequestHeaders = Record<string, unknown>;

export type RequestWithIdempotency = {
  headers?: RequestHeaders;
  getIdempotencyKey?: () => string | null | undefined;
};

const STORE = new Map<string, Entry>();
const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;

function now() {
  return Date.now();
}

function sweepExpired() {
  const cutoff = now();
  for (const [key, entry] of STORE) {
    if (entry.expiresAt < cutoff) {
      STORE.delete(key);
    }
  }
}

export function remember(key: string, fingerprint: string, jobId: number) {
  sweepExpired();
  STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
}

export function lookup(key: string): Entry | undefined {
  sweepExpired();
  return STORE.get(key);
}

export function fingerprintRequest(input: FingerprintInput): string {
  const method = (input.method ?? '').toUpperCase();
  const path = input.path ?? '';
  const normalizedBody = normalizeJson(input.body ?? null);
  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
}

export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
  const value = Array.isArray(raw) ? raw[0] : raw;
  if (typeof value !== 'string') {
    return null;
  }
  const trimmed = value.trim();
  return trimmed.length > 0 ? trimmed : null;
}

export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
  if (typeof request.getIdempotencyKey === 'function') {
    const decorated = request.getIdempotencyKey();
    if (typeof decorated === 'string' && decorated.length > 0) {
      return decorated;
    }
  }

  const raw = getHeaderValue(request.headers, 'idempotency-key');
  return normalizeIdempotencyKey(raw);
}

export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
  if (!key) {
    return null;
  }

  const entry = lookup(key);
  if (!entry) {
    return null;
  }

  if (entry.fingerprint !== fingerprint) {
    throw problem({
      status: 422,
      code: 'idempotency_conflict',
      message: 'Idempotency fingerprint mismatch',
      details: { idempotency_key: key },
    });
  }

  return entry.jobId;
}

export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
  if (!key) {
    return;
  }
  remember(key, fingerprint, jobId);
}

function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
  if (!headers) {
    return undefined;
  }

  const lowerName = name.toLowerCase();
  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase() === lowerName) {
      if (typeof value === 'string' || Array.isArray(value)) {
        return value;
      }
      return undefined;
    }
  }

  return undefined;
}

function normalizeJson(value: unknown): unknown {
  if (value === undefined) {
    return null;
  }

  if (value === null) {
    return null;
  }

  if (Array.isArray(value)) {
    return value.map(normalizeJson);
  }

  if (isPlainObject(value)) {
    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
    const normalized: Record<string, unknown> = {};
    for (const [key, child] of entries) {
      normalized[key] = normalizeJson(child);
    }
    return normalized;
  }

  return value;
}

function isPlainObject(value: unknown): value is Record<string, unknown> {
  return Object.prototype.toString.call(value) === '[object Object]';
}
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
A apps/api/src/lib/idempotency.ts
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Verifying imports and updating route logic**
file update
M /var/home/rick/Development/playlist-manager/apps/api/src/routes/exports/file.post.ts
@@ -2,2 +2,8 @@
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
@@ -31,2 +37,9 @@
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
@@ -38,2 +51,3 @@
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M apps/api/src/routes/exports/file.post.ts
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Updating migrate.post for idempotency**
file update
M /var/home/rick/Development/playlist-manager/apps/api/src/routes/jobs/migrate.post.ts
@@ -2,2 +2,8 @@
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
@@ -35,2 +41,9 @@
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
@@ -43,2 +56,3 @@
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M apps/api/src/routes/jobs/migrate.post.ts
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Implementing idempotency plugin**
file update
A /var/home/rick/Development/playlist-manager/apps/api/src/plugins/idempotency.ts
import fp from 'fastify-plugin';
import type { FastifyRequest } from 'fastify';

import { normalizeIdempotencyKey } from '../lib/idempotency';

export default fp(async (app) => {
  app.decorateRequest(
    'getIdempotencyKey',
    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
      return normalizeIdempotencyKey(raw);
    },
  );
});

declare module 'fastify' {
  interface FastifyRequest {
    getIdempotencyKey(): string | null;
  }
}
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
A apps/api/src/plugins/idempotency.ts
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Updating plugin registration in start.ts**
file update
M /var/home/rick/Development/playlist-manager/apps/api/src/dev/start.ts
@@ -12,2 +12,3 @@
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
@@ -24,2 +25,3 @@
 await app.register(featureGuard);
+await app.register(idempotency);
 
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M apps/api/src/dev/start.ts
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Checking plugin registration points**
exec
bash -lc 'rg -n "featureGuard" -n' in /var/home/rick/Development/playlist-manager succeeded in 49ms:
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:243:import featureGuard from '../plugins/feature-guard.js';
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:9263: await app.register(featureGuard);
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:9304: await app.register(featureGuard);
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:9850: await app.register(featureGuard);
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:10365:bash -lc 'rg -n "featureGuard" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_08c_route_jobs_migrate_1763309492.log:206:import featureGuard from './plugins/feature-guard.js';
codex/LOGS/tasklog_08c_route_jobs_migrate_1763309492.log:521:codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:515:I’m aligning the 503 error with the standard problem format and updating the `featureGuard` plugin to throw errors via the `problem` function for consistent envelopes. I’m also exploring how to hook the `requireProvider` method into routes, considering `request.server` to access the Fastify instance with the plugin decorators for guarding routes, and thinking about leveraging route options for `preHandler` hooks without overhauling all route definitions. Finally, I’ll check the OpenAPI spec to confirm requirements for provider enforcement.
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:365:import featureGuard from '../plugins/feature-guard.js';
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:515:I’m aligning the 503 error with the standard problem format and updating the `featureGuard` plugin to throw errors via the `problem` function for consistent envelopes. I’m also exploring how to hook the `requireProvider` method into routes, considering `request.server` to access the Fastify instance with the plugin decorators for guarding routes, and thinking about leveraging route options for `preHandler` hooks without overhauling all route definitions. Finally, I’ll check the OpenAPI spec to confirm requirements for provider enforcement.
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:1932:    const featureGuard = (await import('../../plugins/feature-guard')).default;
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:1936:    await app.register(featureGuard);
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:2043:+    const featureGuard = (await import('../../plugins/feature-guard')).default;
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:2047:+    await app.register(featureGuard);
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:2225:+    const featureGuard = (await import('../../plugins/feature-guard')).default;
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:2229:+    await app.register(featureGuard);
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:2432:+    const featureGuard = (await import('../../plugins/feature-guard')).default;
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:2436:+    await app.register(featureGuard);
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:2626:+    const featureGuard = (await import('../../plugins/feature-guard')).default;
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:2630:+    await app.register(featureGuard);
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:2808:+    const featureGuard = (await import('../../plugins/feature-guard')).default;
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae8fb64b2f6d798bde5dc0ea27739f423e90fd3a
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,47 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77 as any);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Improving test environment setup**

I’m making sure the TTL test resets module cache before importing to get fresh env values and removing unnecessary type casts. This should fix flaky env-dependent tests and keep them consistent.
file update
M /var/home/rick/Development/playlist-manager/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -12,2 +12,3 @@
     process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
 
@@ -15,3 +16,3 @@
 
-    remember('ttl-key', 'fingerprint-a', 77 as any);
+    remember('ttl-key', 'fingerprint-a', 77);
     expect(lookup('ttl-key')?.jobId).toBe(77);
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M apps/api/src/lib/__tests__/idempotency.test.ts
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Verifying environment variable dependencies**

I'm checking how importing the env config affects tests, especially since the new idempotency module import now requires a `MASTER_KEY` env variable that some tests might not set. I’m pondering ways to avoid test failures, like making `MASTER_KEY` optional in the schema, lazy loading env, or refactoring `env.ts` to separate TTL parsing from the mandatory keys. This is tricky since multiple modules import `env` expecting the key. I'll search usages next to see how broadly the impact spreads.
exec
bash -lc 'rg -n "config/env" -n' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:86:  - apps/api/src/config/env.ts (TTL)
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:216:bash -lc "sed -n '1,200p' apps/api/src/config/env.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:664:apps/api/src/config/env.ts:12:  MASTER_KEY: process.env.MASTER_KEY,
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:704:codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:41588:- Implemented libsodium-style sealed-box keystore with key fingerprinting and tamper detection (`packages/db/src/encryption/crypto.ts:24`, `packages/db/src/encryption/crypto.ts:102`), re-exported for API use (`apps/api/src/lib/crypto/keystore.ts:1`), and validated env loading (`apps/api/src/config/env.ts:1`).
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:705:codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:42339:- Implemented libsodium-style sealed-box keystore with key fingerprinting and tamper detection (`packages/db/src/encryption/crypto.ts:24`, `packages/db/src/encryption/crypto.ts:102`), re-exported for API use (`apps/api/src/lib/crypto/keystore.ts:1`), and validated env loading (`apps/api/src/config/env.ts:1`).
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3403:M /var/home/rick/Development/playlist-manager/apps/api/src/config/env.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3418:M apps/api/src/config/env.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3420:diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3422:--- a/apps/api/src/config/env.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3423:+++ b/apps/api/src/config/env.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3702:diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3704:--- a/apps/api/src/config/env.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3705:+++ b/apps/api/src/config/env.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3987:M /var/home/rick/Development/playlist-manager/apps/api/src/config/env.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3995:M apps/api/src/config/env.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3997:diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3999:--- a/apps/api/src/config/env.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:4000:+++ b/apps/api/src/config/env.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:4279:diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:4281:--- a/apps/api/src/config/env.ts
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Refining search scope**
exec
bash -lc 'rg -n "../config/env" apps/api/src -g"*.ts"' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
apps/api/src/lib/idempotency.ts:1:import { env } from '../config/env';
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Analyzing env import impact on tests**
exec
bash -lc 'rg -n "MASTER_KEY" -n' in /var/home/rick/Development/playlist-manager succeeded in 49ms:
scripts/rotate-token-key.ts:67:  const previousKey = process.env.MASTER_KEY_PREVIOUS;
scripts/rotate-token-key.ts:68:  const nextKey = process.env.MASTER_KEY;
scripts/rotate-token-key.ts:72:      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
README.md:38:Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
README.md:41:1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:220:  MASTER_KEY: z
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:222:      required_error: 'MASTER_KEY env var is required',
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:228:  MASTER_KEY: process.env.MASTER_KEY,
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:664:apps/api/src/config/env.ts:12:  MASTER_KEY: process.env.MASTER_KEY,
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:683:apps/api/src/lib/crypto/__tests__/keystore.test.ts:22:    process.env.MASTER_KEY = masterKey;
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3413:   MASTER_KEY: process.env.MASTER_KEY,
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3425:       required_error: 'MASTER_KEY env var is required',
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3436:   MASTER_KEY: process.env.MASTER_KEY,
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3707:       required_error: 'MASTER_KEY env var is required',
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:3718:   MASTER_KEY: process.env.MASTER_KEY,
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:4002:       required_error: 'MASTER_KEY env var is required',
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:4013:   MASTER_KEY: process.env.MASTER_KEY,
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:4284:       required_error: 'MASTER_KEY env var is required',
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:4295:   MASTER_KEY: process.env.MASTER_KEY,
codex/LOGS/tasklog_08z_idempotency_keys_1763311245.log:4599:       required_error: 'MASTER_KEY env var is required',
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Analyzing MASTER_KEY env dependency**
exec
bash -lc "rg -n \"env\\.\" apps/api/src -g\"*.ts\"" in /var/home/rick/Development/playlist-manager succeeded in 43ms:
apps/api/src/config/env.ts:17:  MASTER_KEY: process.env.MASTER_KEY,
apps/api/src/config/env.ts:18:  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
apps/api/src/config/flags.ts:8:    spotify: bool(process.env.PROVIDERS_SPOTIFY_ENABLED, true),
apps/api/src/config/flags.ts:9:    deezer:  bool(process.env.PROVIDERS_DEEZER_ENABLED, false),
apps/api/src/config/flags.ts:10:    tidal:   bool(process.env.PROVIDERS_TIDAL_ENABLED, false),
apps/api/src/config/flags.ts:11:    youtube: bool(process.env.PROVIDERS_YOUTUBE_ENABLED, false)
apps/api/src/plugins/logging.ts:5:  const logger = pino({ level: process.env.LOG_LEVEL ?? 'info' });
apps/api/src/routes/__tests__/auth.providers.test.ts:11:  delete process.env.PROVIDERS_SPOTIFY_ENABLED;
apps/api/src/routes/__tests__/auth.providers.test.ts:12:  delete process.env.PROVIDERS_DEEZER_ENABLED;
apps/api/src/routes/__tests__/auth.providers.test.ts:13:  delete process.env.PROVIDERS_TIDAL_ENABLED;
apps/api/src/routes/__tests__/auth.providers.test.ts:14:  delete process.env.PROVIDERS_YOUTUBE_ENABLED;
apps/api/src/routes/__tests__/auth.providers.test.ts:72:    process.env.PROVIDERS_SPOTIFY_ENABLED = 'false';
apps/api/src/routes/__tests__/auth.providers.test.ts:73:    process.env.PROVIDERS_DEEZER_ENABLED = 'true';
apps/api/src/routes/__tests__/auth.providers.test.ts:97:    process.env.PROVIDERS_SPOTIFY_ENABLED = 'false';
apps/api/src/routes/__tests__/auth.providers.test.ts:98:    process.env.PROVIDERS_DEEZER_ENABLED = 'true';
apps/api/src/dev/ensure-api-dev.ts:30:    host = process.env.API_HOST ?? '0.0.0.0',
apps/api/src/dev/ensure-api-dev.ts:31:    port = Number.parseInt(process.env.API_PORT ?? '3101', 10),
apps/api/src/dev/start.ts:35:const port = Number(process.env.API_PORT ?? 3101);
apps/api/src/lib/idempotency.ts:14:const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
apps/api/src/lib/crypto/__tests__/keystore.test.ts:22:    process.env.MASTER_KEY = masterKey;
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Verifying MASTER_KEY environment variable**
exec
bash -lc 'echo ${MASTER_KEY:-<unset>}' in /var/home/rick/Development/playlist-manager succeeded in 37ms:
<unset>
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


Reconnecting... 1/5

thinking
**Evaluating options to handle MASTER_KEY in tests**

I'm weighing approaches to avoid import errors from `env` due to missing `MASTER_KEY` during tests. Ideas include lazy parsing TTL, separating TTL parsing in `env.ts`, or setting `process.env.MASTER_KEY` globally in test setup files to satisfy imports that need it early. I'll explore repo-wide occurrences of `MASTER_KEY` assignments to find best places to set defaults for a smooth test environment.
exec
bash -lc 'rg -n "MASTER_KEY" apps -g"*.test.ts"' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
apps/api/src/lib/crypto/__tests__/keystore.test.ts:22:    process.env.MASTER_KEY = masterKey;
apps/api/src/lib/crypto/__tests__/keystore.test.ts:37:  it('throws when MASTER_KEY is missing', () => {
apps/api/src/lib/crypto/__tests__/keystore.test.ts:38:    delete process.env.MASTER_KEY;
apps/api/src/lib/crypto/__tests__/keystore.test.ts:39:    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
apps/api/src/lib/crypto/__tests__/keystore.test.ts:42:  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
apps/api/src/lib/crypto/__tests__/keystore.test.ts:43:    process.env.MASTER_KEY = 'invalid';
apps/api/src/lib/crypto/__tests__/keystore.test.ts:44:    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
apps/api/src/lib/crypto/__tests__/keystore.test.ts:51:    process.env.MASTER_KEY = makeMasterKey();
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f6ae6d10ebea6fa923ea64336b7a101c63146a58
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -6,8 +6,14 @@
       required_error: 'MASTER_KEY env var is required',
     })
     .min(1),
+  IDEMPOTENCY_TTL_SECONDS: z.coerce
+    .number()
+    .int()
+    .positive()
+    .default(15 * 60),
 });
 
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
+  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Refactoring environment config for tests**
file update
M /var/home/rick/Development/playlist-manager/apps/api/src/config/env.ts
@@ -8,12 +8,14 @@
     .min(1),
-  IDEMPOTENCY_TTL_SECONDS: z.coerce
-    .number()
-    .int()
-    .positive()
-    .default(15 * 60),
 });
 
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
-  IDEMPOTENCY_TTL_SECONDS: process.env.IDEMPOTENCY_TTL_SECONDS,
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M apps/api/src/config/env.ts
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f44f5900629b5cd37215de9ec487094056da5694
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,14 @@
     .min(1),
 });
 
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f44f5900629b5cd37215de9ec487094056da5694
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,14 @@
     .min(1),
 });
 
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..19b91df2b388cfc5e452e59e7723fd5e5c4f37c8
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { env } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Modifying idempotency import and constant usage**
file update
M /var/home/rick/Development/playlist-manager/apps/api/src/lib/idempotency.ts
@@ -1,2 +1,2 @@
-import { env } from '../config/env';
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
 import { problem } from './problem';
@@ -13,3 +13,3 @@
 const STORE = new Map<string, Entry>();
-const TTL_MS = env.IDEMPOTENCY_TTL_SECONDS * 1000;
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
 
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M apps/api/src/lib/idempotency.ts
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f44f5900629b5cd37215de9ec487094056da5694
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,14 @@
     .min(1),
 });
 
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f44f5900629b5cd37215de9ec487094056da5694
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,14 @@
     .min(1),
 });
 
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Analyzing env import side effects**

I'm investigating why importing only the `IDEMPOTENCY_TTL_SECONDS` from the env module still triggers the parsing of `MASTER_KEY` due to how the env module is structured. It looks like module evaluation runs both schema parses eagerly, so I’m considering refactoring to lazily parse `env` only when needed, while checking for existing imports of the `env` object across the codebase.
exec
bash -lc "rg -n \"import \\{ env\" -g\"*.ts\"" in /var/home/rick/Development/playlist-manager exited 1 in 43ms:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..f44f5900629b5cd37215de9ec487094056da5694
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,14 @@
     .min(1),
 });
 
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
 export const env = EnvSchema.parse({
   MASTER_KEY: process.env.MASTER_KEY,
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Refactoring env module for lazy parsing**
file update
M /var/home/rick/Development/playlist-manager/apps/api/src/config/env.ts
@@ -16,4 +16,18 @@
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M apps/api/src/config/env.ts
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Verifying env parsing and test updates**

I’m checking that the new Proxy-based lazy parsing of environment variables avoids unnecessary parsing on import and plays well with TypeScript types, resets in tests, and the Fastify plugin setup. I’m also confirming that TTL constants, route tests, and idempotency key handling remain correct after these changes.
Plan update
  ✓ Extend OpenAPI spec for Idempotency-Key header + 422 response on export/migrate endpoints.
  ✓ Add failing tests covering repeated requests/conflicts (routes) and TTL behavior for the idempotency store.
  ✓ Implement idempotency fingerprinting/store logic, plugin + env config, route wiring, and register the plugin.
  → Run the relevant test suite(s) and prepare the commit.
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Running full test suite**

I'm preparing to run the complete test suite with `pnpm vitest` to verify all tests pass, even though it could take some time due to the monorepo size. I'm checking if environment variables like `MASTER_KEY` need to be set, but overall, the tests should run fine as is.
exec
bash -lc 'pnpm vitest' in /var/home/rick/Development/playlist-manager exited 124 in 2m 00s:

 DEV  v3.1.1 /var/home/rick/Development/playlist-manager

 ✓ codex/code/codex/07a_routes_playlist_items_effective/tests/route.items.test.ts (2 tests) 13ms
 ✓ codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts (1 test) 13ms
 ✓ codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts (2 tests) 21ms
 ✓ codex/code/codex/08d_worker_jobs_migrate/tests/migrate.worker.test.ts (1 test) 8ms
 ✓ codex/code/codex/06f_provider_factory_tests/tests/providers.factory.test.ts (4 tests) 142ms
 ❯ apps/api/src/routes/__tests__/auth.providers.test.ts (2 tests | 1 failed) 24ms
   ✓ GET /auth/providers > omits providers that are disabled via flags 15ms
   × feature guard middleware > blocks provider-dependent routes when a provider is disabled 8ms
     → Failed to load url nanoid (resolved id: nanoid) in /var/home/rick/Development/playlist-manager/apps/api/src/plugins/errors.ts. Does the file exist?
 ✓ apps/api/src/routes/__tests__/jobs.events.test.ts (2 tests) 15ms
 ✓ codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts (2 tests) 23ms
 ✓ codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts (2 tests) 22ms
 ✓ packages/providers/core/test/fixtureHarness.test.ts (2 tests) 37ms
 ✓ codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts (2 tests) 26ms
 ✓ packages/interop/test/importers/file-importers.test.ts (8 tests) 21ms
 ✓ apps/worker/src/lib/__tests__/progress.test.ts (3 tests) 11ms
 ✓ packages/providers/core/test/mbidResolver.test.ts (5 tests) 9ms
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Running targeted tests due to environment issues**
exec
bash -lc 'pnpm vitest run apps/api/src/routes/__tests__/idempotency.test.ts apps/api/src/lib/__tests__/idempotency.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 1.99s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ❯ apps/api/src/lib/__tests__/idempotency.test.ts (2 tests | 2 failed) 26ms
   × idempotency store > expires remembered keys after the configured TTL 22ms
     → Failed to load url zod (resolved id: zod) in /var/home/rick/Development/playlist-manager/apps/api/src/config/env.ts. Does the file exist?
   × idempotency store > computes identical fingerprints for the same payload regardless of key order 3ms
     → Failed to load url zod (resolved id: zod) in /var/home/rick/Development/playlist-manager/apps/api/src/config/env.ts. Does the file exist?

⎯⎯⎯⎯⎯⎯ Failed Suites 1 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  apps/api/src/routes/__tests__/idempotency.test.ts [ apps/api/src/routes/__tests__/idempotency.test.ts ]
Error: Failed to load url zod (resolved id: zod) in /var/home/rick/Development/playlist-manager/apps/api/src/config/env.ts. Does the file exist?
 ❯ loadAndTransform node_modules/vite/dist/node/chunks/dep-Bid9ssRr.js:41317:17

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/3]⎯


⎯⎯⎯⎯⎯⎯⎯ Failed Tests 2 ⎯⎯⎯⎯⎯⎯⎯

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Investigating Vite zod resolution issue**
exec
bash -lc 'ls node_modules | head' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
acorn
acorn-jsx
ajv
@ampproject
ansi-align
ansi-escapes
ansi-regex
ansis
ansi-styles
@antfu
ls: write error: Broken pipe
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Checking zod module presence**
exec
bash -lc 'ls node_modules/zod' in /var/home/rick/Development/playlist-manager exited 2 in 39ms:
ls: cannot access 'node_modules/zod': No such file or directory
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Investigating missing zod package**
exec
bash -lc 'ls node_modules/.pnpm | grep zod | head' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
zod@4.1.12
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Investigating missing package symlink**
exec
bash -lc 'pnpm list zod' in /var/home/rick/Development/playlist-manager succeeded in 1.15s:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Investigating pnpm dependency links**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
{
  "name": "playlist-manager",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "packageManager": "pnpm@9.12.3",
  "engines": {
    "node": ">=18.18"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "lint:api": "redocly lint openapi.yaml --extends recommended",
    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    "mock:api": "prism mock openapi.yaml",
    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",
    "contract:test": "schemathesis run openapi.yaml --checks all --hypothesis-deadline=1000",
    "prisma:generate": "pnpm -F @app/db exec prisma generate",
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Investigating missing symlinks in node_modules**
exec
bash -lc 'ls node_modules/nanoid' in /var/home/rick/Development/playlist-manager exited 2 in 40ms:
ls: cannot access 'node_modules/nanoid': No such file or directory
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Investigating dependency symlinks**
exec
bash -lc 'cat .npmrc' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
ignore-workspace-root-check=true
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Examining missing direct dependencies in node_modules**
exec
bash -lc 'ls node_modules/.pnpm/zod@4.1.12/node_modules' in /var/home/rick/Development/playlist-manager succeeded in 38ms:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Investigating potential empty directory**
exec
bash -lc 'ls node_modules/.pnpm/zod@4.1.12/node_modules/zod' in /var/home/rick/Development/playlist-manager exited 2 in 38ms:
ls: cannot access 'node_modules/.pnpm/zod@4.1.12/node_modules/zod': No such file or directory
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Investigating pnpm package structure**
exec
bash -lc "find node_modules/.pnpm -maxdepth 1 -name 'zod*' -print" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
node_modules/.pnpm/zod@4.1.12
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Checking pnpm symlink**
exec
bash -lc 'ls -l node_modules/.pnpm/zod@4.1.12' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
total 0
drwxr-xr-x 1 rick rick 0 Nov  5 23:35 node_modules
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Checking node_modules directory**
exec
bash -lc 'ls -l node_modules/.pnpm/zod@4.1.12/node_modules' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
total 0
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Investigating pnpm package storage**
exec
bash -lc 'ls -a node_modules/.pnpm/zod@4.1.12/node_modules' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
.
..
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Investigating empty folder issue**
exec
bash -lc 'ls node_modules/acorn' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
bin
CHANGELOG.md
dist
LICENSE
package.json
README.md
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Investigating package hoisting mechanism**
exec
bash -lc 'cat node_modules/.modules.yaml | head -n 40' in /var/home/rick/Development/playlist-manager succeeded in 46ms:
cat: node_modules/.modules.yaml: No such file or directory
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Analyzing missing dependencies issue**
exec
bash -lc "find node_modules/.pnpm -maxdepth 1 -name 'nanoid*' -print" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
node_modules/.pnpm/nanoid@5.1.6
node_modules/.pnpm/nanoid@3.3.11
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Investigating missing package dependencies**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 80ms:
## main...origin/main [ahead 19]
 M apps/api/src/config/env.ts
 M apps/api/src/dev/start.ts
 M apps/api/src/lib/idempotency.ts
 M apps/api/src/routes/exports/file.post.ts
 M apps/api/src/routes/jobs/migrate.post.ts
 M openapi.yaml
?? Jackett.Binaries.LinuxAMDx64.tar.gz
?? Jackett/
?? apps/api/src/lib/__tests__/
?? apps/api/src/plugins/idempotency.ts
?? apps/api/src/routes/__tests__/idempotency.test.ts
?? codex/LOGS/codex_run_2025-11-16_08-49-16.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log.done
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log.done
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log.done
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Filtering relevant files for staging**
exec
bash -lc 'git diff -- openapi.yaml' in /var/home/rick/Development/playlist-manager succeeded in 80ms:
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a..1656d25 100644
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@ paths:
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Reviewing environment file changes**
exec
bash -lc 'git diff -- apps/api/src/config/env.ts' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4..090a178 100644
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@ const EnvSchema = z.object({
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Verifying TTL removal from schema**
exec
bash -lc "sed -n '1,80p' apps/api/src/config/env.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import { z } from 'zod';

const EnvSchema = z.object({
  MASTER_KEY: z
    .string({
      required_error: 'MASTER_KEY env var is required',
    })
    .min(1),
});

const IdempotencyTtlSchema = z.coerce
  .number()
  .int()
  .positive()
  .default(15 * 60);

type Env = z.infer<typeof EnvSchema>;
let envCache: Env | null = null;

function loadEnv(): Env {
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Reviewing zod import and constants**
exec
bash -lc 'git diff -- apps/api/src/lib/idempotency.ts' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf3..9d66ce7 100644
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Verifying function relocation and exports**
exec
bash -lc 'git diff -- apps/api/src/routes/exports/file.post.ts' in /var/home/rick/Development/playlist-manager succeeded in 82ms:
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb..ad7d6b1 100644
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@ export default async function handler(
   });
 
   const payload = request.body;
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Preparing files and updating tests plan**
exec
bash -lc 'git add openapi.yaml apps/api/src/config/env.ts apps/api/src/lib/idempotency.ts apps/api/src/routes/exports/file.post.ts apps/api/src/routes/jobs/migrate.post.ts apps/api/src/lib/__tests__/idempotency.test.ts apps/api/src/routes/__tests__/idempotency.test.ts apps/api/src/dev/start.ts apps/api/src/plugins/idempotency.ts' in /var/home/rick/Development/playlist-manager succeeded in 42ms:

file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Verifying staged changes**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
## main...origin/main [ahead 19]
M  apps/api/src/config/env.ts
M  apps/api/src/dev/start.ts
A  apps/api/src/lib/__tests__/idempotency.test.ts
M  apps/api/src/lib/idempotency.ts
A  apps/api/src/plugins/idempotency.ts
A  apps/api/src/routes/__tests__/idempotency.test.ts
M  apps/api/src/routes/exports/file.post.ts
M  apps/api/src/routes/jobs/migrate.post.ts
M  openapi.yaml
?? Jackett.Binaries.LinuxAMDx64.tar.gz
?? Jackett/
?? codex/LOGS/codex_run_2025-11-16_08-49-16.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log.done
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log.done
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log.done
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Checking staged changes before commit**
exec
bash -lc 'git diff --cached' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4..090a178 100644
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@ const EnvSchema = z.object({
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Updating plan with test status**
Plan update
Attempted to run the full Vitest suite, but the sandbox lacks symlinked dependencies (e.g., zod, nanoid, @prisma/client, Prisma scripts), so Vitest fails before our specs execute. Logged the failure details and cannot fix the environment from here.
  ✓ Extend OpenAPI spec for Idempotency-Key header + 422 response on export/migrate endpoints.
  ✓ Add failing tests covering repeated requests/conflicts (routes) and TTL behavior for the idempotency store.
  ✓ Implement idempotency fingerprinting/store logic, plugin + env config, route wiring, and register the plugin.
  ✓ Run the relevant test suite(s) and prepare the commit.
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Preparing commit message**
exec
bash -lc 'git commit -m "feat(api): add idempotency keys for job enqueue routes"' in /var/home/rick/Development/playlist-manager succeeded in 51ms:
[main 53f8c27] feat(api): add idempotency keys for job enqueue routes
 9 files changed, 405 insertions(+), 11 deletions(-)
 create mode 100644 apps/api/src/lib/__tests__/idempotency.test.ts
 create mode 100644 apps/api/src/plugins/idempotency.ts
 create mode 100644 apps/api/src/routes/__tests__/idempotency.test.ts
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Checking git status for untracked files**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
## main...origin/main [ahead 20]
?? Jackett.Binaries.LinuxAMDx64.tar.gz
?? Jackett/
?? codex/LOGS/codex_run_2025-11-16_08-49-16.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log.done
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log.done
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log.done
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log.done
?? codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log
?? codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log.done
?? codex/LOGS/tasklog_08b_worker_export_file_1763307527.log
?? codex/LOGS/tasklog_08b_worker_export_file_1763307527.log.done
?? codex/LOGS/tasklog_08c_route_jobs_migrate_1763309492.log
?? codex/LOGS/tasklog_08c_route_jobs_migrate_1763309492.log.done
?? codex/LOGS/tasklog_08d_worker_jobs_migrate_1763310116.log
?? codex/LOGS/tasklog_08d_worker_jobs_migrate_1763310116.log.done
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:


thinking
**Summarizing final commit and test details**

I'll prepare a clear summary covering all major code changes with file paths and line refs, note the spec additions, plugin registration, and env TTL update. Then I'll explain that test runs failed due to missing dependencies like `zod` and `nanoid`, including the error messages and attempted commands. Finally, I’ll include the full commit message, a bulleted list of modified files with brief descriptions, and a git status report mentioning untracked log files, plus note that the commit was not pushed per instructions.
codex
**Idempotency Support**
- Documented the optional `Idempotency-Key` header plus 422 `IdempotencyConflict` responses for `/jobs/migrate` and `/exports/file` to keep the spec authoritative (`openapi.yaml:265`, `openapi.yaml:519`, `openapi.yaml:738`).
- Added a lazily-evaluated env reader and exported `IDEMPOTENCY_TTL_SECONDS`, keeping the master key validation while making the TTL configurable (`apps/api/src/config/env.ts:3`).
- Rebuilt the idempotency helper to normalize request bodies, compute fingerprints, manage TTL-backed storage, and expose helpers for key extraction/reuse (`apps/api/src/lib/idempotency.ts:1`).
- Introduced a Fastify plugin to expose `request.getIdempotencyKey()` and registered it in the dev server (`apps/api/src/plugins/idempotency.ts:1`, `apps/api/src/dev/start.ts:10`).
- Wired `/exports/file` and `/jobs/migrate` to reuse job refs or raise `idempotency_conflict` via the new helpers (`apps/api/src/routes/exports/file.post.ts:1`, `apps/api/src/routes/jobs/migrate.post.ts:1`).
- Covered the behavior with new route-level tests and store unit tests, including TTL expiry and fingerprint normalization (`apps/api/src/routes/__tests__/idempotency.test.ts:1`, `apps/api/src/lib/__tests__/idempotency.test.ts:1`).

**Tests**
- `pnpm vitest` → fails before our specs run because the sandbox does not expose direct installs of several dependencies (`zod`, `nanoid`, `@prisma/client`, Prisma scripts); Vitest exits with repeated “Failed to load url … Does the file exist?” errors.
- `pnpm vitest run apps/api/src/routes/__tests__/idempotency.test.ts apps/api/src/lib/__tests__/idempotency.test.ts` → same resolution failure (`zod` cannot be resolved), so the new tests cannot execute until the workspace exposes those packages.

Commit:
- `feat(api): add idempotency keys for job enqueue routes`

Modified files:
- `openapi.yaml`
- `apps/api/src/config/env.ts`
- `apps/api/src/lib/idempotency.ts`
- `apps/api/src/plugins/idempotency.ts`
- `apps/api/src/dev/start.ts`
- `apps/api/src/routes/exports/file.post.ts`
- `apps/api/src/routes/jobs/migrate.post.ts`
- `apps/api/src/routes/__tests__/idempotency.test.ts`
- `apps/api/src/lib/__tests__/idempotency.test.ts`

Git status:
- Working tree clean for tracked files; pre-existing untracked artifacts (Jackett binaries and various `codex/LOGS`/`codex/TASKS` files) remain untouched.
file update:
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
index 5a6d5d4badaa727f3b914daf0677ff6f81f90a32..090a178d3b197e06383954f9183497395f3d9698
--- a/apps/api/src/config/env.ts
+++ b/apps/api/src/config/env.ts
@@ -8,6 +8,28 @@
     .min(1),
 });
 
-export const env = EnvSchema.parse({
-  MASTER_KEY: process.env.MASTER_KEY,
+const IdempotencyTtlSchema = z.coerce
+  .number()
+  .int()
+  .positive()
+  .default(15 * 60);
+
+type Env = z.infer<typeof EnvSchema>;
+let envCache: Env | null = null;
+
+function loadEnv(): Env {
+  if (!envCache) {
+    envCache = EnvSchema.parse({
+      MASTER_KEY: process.env.MASTER_KEY,
+    });
+  }
+  return envCache;
+}
+
+export const env: Env = new Proxy({} as Env, {
+  get(_target, prop) {
+    return loadEnv()[prop as keyof Env];
+  },
 });
+
+export const IDEMPOTENCY_TTL_SECONDS = IdempotencyTtlSchema.parse(process.env.IDEMPOTENCY_TTL_SECONDS);
diff --git a/apps/api/src/dev/start.ts b/apps/api/src/dev/start.ts
index 79ac53f4683317601b1718c5901c61932fe7096b..6607b095d681565ab06fbdee767e164226fd7ef9
--- a/apps/api/src/dev/start.ts
+++ b/apps/api/src/dev/start.ts
@@ -10,6 +10,7 @@
 import errorsPlugin from '../plugins/errors.js';
 import jobEvents from '../routes/jobs.events.js';
 import importsFile from '../routes/imports.file.js';
+import idempotency from '../plugins/idempotency.js';
 
 const app = Fastify({ logger: true });
 
@@ -22,6 +23,7 @@
 await app.register(metrics);
 await app.register(errorsPlugin);
 await app.register(featureGuard);
+await app.register(idempotency);
 
 await app.register(docsRoutes);
 await app.register(authProviders);
diff --git a/apps/api/src/lib/__tests__/idempotency.test.ts b/apps/api/src/lib/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..847036cd2f774b573749c1f2cd7d39ff61a32231
--- /dev/null
+++ b/apps/api/src/lib/__tests__/idempotency.test.ts
@@ -0,0 +1,48 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+describe('idempotency store', () => {
+  afterEach(() => {
+    vi.resetModules();
+    vi.useRealTimers();
+    delete process.env.IDEMPOTENCY_TTL_SECONDS;
+  });
+
+  it('expires remembered keys after the configured TTL', async () => {
+    vi.useFakeTimers();
+    process.env.IDEMPOTENCY_TTL_SECONDS = '1';
+    vi.resetModules();
+
+    const { remember, lookup } = await import('../idempotency');
+
+    remember('ttl-key', 'fingerprint-a', 77);
+    expect(lookup('ttl-key')?.jobId).toBe(77);
+
+    vi.advanceTimersByTime(1000);
+    expect(lookup('ttl-key')).toBeUndefined();
+  });
+
+  it('computes identical fingerprints for the same payload regardless of key order', async () => {
+    const { fingerprintRequest } = await import('../idempotency');
+
+    const first = fingerprintRequest({
+      method: 'POST',
+      path: '/exports/file',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    const second = fingerprintRequest({
+      method: 'post',
+      path: '/exports/file',
+      body: { format: 'csv', variant: 'lean', playlist_id: 11 },
+    });
+
+    const differentPath = fingerprintRequest({
+      method: 'POST',
+      path: '/jobs/migrate',
+      body: { playlist_id: 11, format: 'csv', variant: 'lean' },
+    });
+
+    expect(first).toBe(second);
+    expect(differentPath).not.toBe(first);
+  });
+});
diff --git a/apps/api/src/lib/idempotency.ts b/apps/api/src/lib/idempotency.ts
index 2b36cf34bff10af2a332d65f3731d8321bbb060a..9d66ce7458470958298b5faea4580f54a54be7a0
--- a/apps/api/src/lib/idempotency.ts
+++ b/apps/api/src/lib/idempotency.ts
@@ -1,19 +1,142 @@
-type Entry = { fingerprint: string; jobId: string; expiresAt: number };
+import { IDEMPOTENCY_TTL_SECONDS } from '../config/env';
+import { problem } from './problem';
+
+type Entry = { fingerprint: string; jobId: number; expiresAt: number };
+type FingerprintInput = { method: string; path: string; body: unknown };
+type RequestHeaders = Record<string, unknown>;
+
+export type RequestWithIdempotency = {
+  headers?: RequestHeaders;
+  getIdempotencyKey?: () => string | null | undefined;
+};
+
 const STORE = new Map<string, Entry>();
-const TTL_MS = Number(process.env.IDEMPOTENCY_TTL_MS ?? 15 * 60_000);
+const TTL_MS = IDEMPOTENCY_TTL_SECONDS * 1000;
+
+function now() {
+  return Date.now();
+}
 
-function now() { return Date.now(); }
-function sweep() {
-  const t = now();
-  for (const [k, v] of STORE) if (v.expiresAt < t) STORE.delete(k);
+function sweepExpired() {
+  const cutoff = now();
+  for (const [key, entry] of STORE) {
+    if (entry.expiresAt < cutoff) {
+      STORE.delete(key);
+    }
+  }
 }
 
-export function remember(key: string, fingerprint: string, jobId: string) {
-  sweep();
+export function remember(key: string, fingerprint: string, jobId: number) {
+  sweepExpired();
   STORE.set(key, { fingerprint, jobId, expiresAt: now() + TTL_MS });
 }
 
 export function lookup(key: string): Entry | undefined {
-  sweep();
+  sweepExpired();
   return STORE.get(key);
 }
+
+export function fingerprintRequest(input: FingerprintInput): string {
+  const method = (input.method ?? '').toUpperCase();
+  const path = input.path ?? '';
+  const normalizedBody = normalizeJson(input.body ?? null);
+  return `${method} ${path} ${JSON.stringify(normalizedBody)}`;
+}
+
+export function normalizeIdempotencyKey(raw: string | string[] | undefined): string | null {
+  const value = Array.isArray(raw) ? raw[0] : raw;
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const trimmed = value.trim();
+  return trimmed.length > 0 ? trimmed : null;
+}
+
+export function resolveRequestIdempotencyKey(request: RequestWithIdempotency): string | null {
+  if (typeof request.getIdempotencyKey === 'function') {
+    const decorated = request.getIdempotencyKey();
+    if (typeof decorated === 'string' && decorated.length > 0) {
+      return decorated;
+    }
+  }
+
+  const raw = getHeaderValue(request.headers, 'idempotency-key');
+  return normalizeIdempotencyKey(raw);
+}
+
+export function reuseJobIdIfPresent(key: string | null, fingerprint: string): number | null {
+  if (!key) {
+    return null;
+  }
+
+  const entry = lookup(key);
+  if (!entry) {
+    return null;
+  }
+
+  if (entry.fingerprint !== fingerprint) {
+    throw problem({
+      status: 422,
+      code: 'idempotency_conflict',
+      message: 'Idempotency fingerprint mismatch',
+      details: { idempotency_key: key },
+    });
+  }
+
+  return entry.jobId;
+}
+
+export function storeJobForKey(key: string | null, fingerprint: string, jobId: number): void {
+  if (!key) {
+    return;
+  }
+  remember(key, fingerprint, jobId);
+}
+
+function getHeaderValue(headers: RequestHeaders | undefined, name: string): string | string[] | undefined {
+  if (!headers) {
+    return undefined;
+  }
+
+  const lowerName = name.toLowerCase();
+  for (const [key, value] of Object.entries(headers)) {
+    if (key.toLowerCase() === lowerName) {
+      if (typeof value === 'string' || Array.isArray(value)) {
+        return value;
+      }
+      return undefined;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeJson(value: unknown): unknown {
+  if (value === undefined) {
+    return null;
+  }
+
+  if (value === null) {
+    return null;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map(normalizeJson);
+  }
+
+  if (isPlainObject(value)) {
+    const entries = Object.entries(value as Record<string, unknown>).filter(([, v]) => v !== undefined);
+    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));
+    const normalized: Record<string, unknown> = {};
+    for (const [key, child] of entries) {
+      normalized[key] = normalizeJson(child);
+    }
+    return normalized;
+  }
+
+  return value;
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return Object.prototype.toString.call(value) === '[object Object]';
+}
diff --git a/apps/api/src/plugins/idempotency.ts b/apps/api/src/plugins/idempotency.ts
new file mode 100644
index 0000000000000000000000000000000000000000..850bdfb311b9d3a8d1e85b302fd79c53d48c8d06
--- /dev/null
+++ b/apps/api/src/plugins/idempotency.ts
@@ -0,0 +1,20 @@
+import fp from 'fastify-plugin';
+import type { FastifyRequest } from 'fastify';
+
+import { normalizeIdempotencyKey } from '../lib/idempotency';
+
+export default fp(async (app) => {
+  app.decorateRequest(
+    'getIdempotencyKey',
+    function thisGetIdempotencyKey(this: FastifyRequest): string | null {
+      const raw = this.headers?.['idempotency-key'] as string | string[] | undefined;
+      return normalizeIdempotencyKey(raw);
+    },
+  );
+});
+
+declare module 'fastify' {
+  interface FastifyRequest {
+    getIdempotencyKey(): string | null;
+  }
+}
diff --git a/apps/api/src/routes/__tests__/idempotency.test.ts b/apps/api/src/routes/__tests__/idempotency.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fba7ac3d48aa1065f5a709f95bb4879456334e8
--- /dev/null
+++ b/apps/api/src/routes/__tests__/idempotency.test.ts
@@ -0,0 +1,112 @@
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+vi.mock('../../lib/jobs/enqueue', () => ({
+  enqueue: vi.fn(),
+}));
+
+import { enqueue } from '../../lib/jobs/enqueue';
+import exportsFileHandler from '../exports/file.post';
+import jobsMigrateHandler from '../jobs/migrate.post';
+
+const enqueueMock = vi.mocked(enqueue);
+
+describe('POST /exports/file idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('reuses the original job for repeat payloads with the same Idempotency-Key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 701 }).mockResolvedValueOnce({ id: 702 });
+
+    const firstReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), firstReply as any);
+
+    expect(firstReply.status).toHaveBeenCalledWith(202);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+
+    const secondReply = createReply();
+    await exportsFileHandler(createExportRequest('export-key-1'), secondReply as any);
+
+    expect(secondReply.status).toHaveBeenCalledWith(202);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 701, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe('POST /jobs/migrate idempotency', () => {
+  afterEach(() => {
+    enqueueMock.mockReset();
+  });
+
+  it('returns the original job when the payload is repeated', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 9901 }).mockResolvedValueOnce({ id: 9902 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+
+    const secondReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-1'), secondReply as any);
+    expect(secondReply.send).toHaveBeenCalledWith({ job_id: 9901, status: 'queued' });
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('throws a 422 idempotency_conflict when the payload changes for the same key', async () => {
+    enqueueMock.mockResolvedValueOnce({ id: 8811 });
+
+    const firstReply = createReply();
+    await jobsMigrateHandler(createMigrateRequest('migrate-key-2'), firstReply as any);
+    expect(firstReply.send).toHaveBeenCalledWith({ job_id: 8811, status: 'queued' });
+
+    const mutatedRequest = createMigrateRequest('migrate-key-2', { dest_playlist_name: 'Different name' });
+    const secondReply = createReply();
+
+    await expect(jobsMigrateHandler(mutatedRequest, secondReply as any)).rejects.toMatchObject({
+      statusCode: 422,
+      code: 'idempotency_conflict',
+    });
+
+    expect(enqueueMock).toHaveBeenCalledTimes(1);
+    expect(secondReply.send).not.toHaveBeenCalled();
+  });
+});
+
+function createReply() {
+  return {
+    status: vi.fn().mockReturnThis(),
+    send: vi.fn().mockReturnThis(),
+  };
+}
+
+function createExportRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      playlist_id: 77,
+      format: 'csv',
+      variant: 'lean',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+  };
+}
+
+function createMigrateRequest(key: string, overrides: Record<string, unknown> = {}) {
+  return {
+    body: {
+      source_provider: 'spotify',
+      source_playlist_id: 10,
+      dest_provider: 'spotify',
+      dest_playlist_name: 'Mirror copy',
+      ...overrides,
+    },
+    headers: {
+      'content-type': 'application/json',
+      'idempotency-key': key,
+    },
+    requireProvider: vi.fn(),
+  };
+}
diff --git a/apps/api/src/routes/exports/file.post.ts b/apps/api/src/routes/exports/file.post.ts
index d4e2fbb850db1acd75653c980c1944b482b63fcb..ad7d6b1e8a66723a8c505d582b485210905a00c3
--- a/apps/api/src/routes/exports/file.post.ts
+++ b/apps/api/src/routes/exports/file.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -29,6 +35,13 @@
   });
 
   const payload = request.body;
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/exports/file', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'export_file',
     playlist_id: payload.playlist_id,
@@ -36,5 +49,6 @@
     variant: payload.variant ?? 'lean',
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/apps/api/src/routes/jobs/migrate.post.ts b/apps/api/src/routes/jobs/migrate.post.ts
index 6411b913367c517beef2eda2aff387986d66165f..6588a10ade61419ce5d5ca57f6752723d1dd30de
--- a/apps/api/src/routes/jobs/migrate.post.ts
+++ b/apps/api/src/routes/jobs/migrate.post.ts
@@ -1,5 +1,11 @@
 import { FastifyReply, FastifyRequest } from 'fastify';
 import { enqueue } from '../../lib/jobs/enqueue';
+import {
+  fingerprintRequest,
+  resolveRequestIdempotencyKey,
+  reuseJobIdIfPresent,
+  storeJobForKey,
+} from '../../lib/idempotency';
 import { validateRequestBody } from '../../lib/openapi/validator';
 
 type Body = {
@@ -33,6 +39,13 @@
   request.requireProvider(payload.source_provider);
   request.requireProvider(payload.dest_provider);
 
+  const fingerprint = fingerprintRequest({ method: 'POST', path: '/jobs/migrate', body: payload });
+  const idempotencyKey = resolveRequestIdempotencyKey(request);
+  const existingJobId = reuseJobIdIfPresent(idempotencyKey, fingerprint);
+  if (existingJobId !== null) {
+    return reply.status(202).send({ job_id: existingJobId, status: 'queued' });
+  }
+
   const job = await enqueue({
     kind: 'migrate',
     source_provider: payload.source_provider,
@@ -41,5 +54,6 @@
     dest_playlist_name: payload.dest_playlist_name ?? null,
   });
 
+  storeJobForKey(idempotencyKey, fingerprint, job.id);
   return reply.status(202).send({ job_id: job.id, status: 'queued' });
 }
diff --git a/openapi.yaml b/openapi.yaml
index 63d3e2a4c6152bd00ffaa5dc32dcb6a6d0d49d27..1656d257b9dbdb5edfe1c67cfb24a55a2589efe3
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -265,6 +265,18 @@
     post:
       summary: Migrate a playlist between providers
       operationId: jobs_requestMigration
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -297,6 +309,7 @@
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
         '503': { $ref: '#/components/responses/ServiceUnavailable' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /jobs/{id}:
     get:
@@ -520,6 +533,18 @@
     post:
       summary: Export a playlist to file
       operationId: exports_enqueueFile
+      parameters:
+        - in: header
+          name: Idempotency-Key
+          schema:
+            type: string
+            minLength: 8
+            maxLength: 128
+          required: false
+          description: |
+            Optional key to deduplicate POST attempts for 15 minutes. Reusing the same key with
+            the same request payload returns the original job reference; mismatched payloads
+            return HTTP 422 with code `idempotency_conflict`.
       requestBody:
         required: true
         content:
@@ -549,6 +574,7 @@
         '400': { $ref: '#/components/responses/BadRequest' }
         '401': { $ref: '#/components/responses/Unauthorized' }
         '429': { $ref: '#/components/responses/TooManyRequests' }
+        '422': { $ref: '#/components/responses/IdempotencyConflict' }
 
   /artists/{mbid}/follow:
     post:
@@ -738,6 +764,19 @@
                 code: service_unavailable
                 message: Service temporarily unavailable
                 details: { request_id: req_503svc }
+    IdempotencyConflict:
+      description: Idempotency fingerprint conflict
+      content:
+        application/json:
+          schema: { $ref: '#/components/schemas/Error' }
+          examples:
+            mismatch:
+              summary: Key reused with a different request payload
+              value:
+                type: 'about:blank'
+                code: idempotency_conflict
+                message: Idempotency fingerprint mismatch for this key
+                details: { request_id: req_422idmp }
     UnprocessableEntity:
       description: Unprocessable entity
       content:

tokens used
238,375
**Idempotency Support**
- Documented the optional `Idempotency-Key` header plus 422 `IdempotencyConflict` responses for `/jobs/migrate` and `/exports/file` to keep the spec authoritative (`openapi.yaml:265`, `openapi.yaml:519`, `openapi.yaml:738`).
- Added a lazily-evaluated env reader and exported `IDEMPOTENCY_TTL_SECONDS`, keeping the master key validation while making the TTL configurable (`apps/api/src/config/env.ts:3`).
- Rebuilt the idempotency helper to normalize request bodies, compute fingerprints, manage TTL-backed storage, and expose helpers for key extraction/reuse (`apps/api/src/lib/idempotency.ts:1`).
- Introduced a Fastify plugin to expose `request.getIdempotencyKey()` and registered it in the dev server (`apps/api/src/plugins/idempotency.ts:1`, `apps/api/src/dev/start.ts:10`).
- Wired `/exports/file` and `/jobs/migrate` to reuse job refs or raise `idempotency_conflict` via the new helpers (`apps/api/src/routes/exports/file.post.ts:1`, `apps/api/src/routes/jobs/migrate.post.ts:1`).
- Covered the behavior with new route-level tests and store unit tests, including TTL expiry and fingerprint normalization (`apps/api/src/routes/__tests__/idempotency.test.ts:1`, `apps/api/src/lib/__tests__/idempotency.test.ts:1`).

**Tests**
- `pnpm vitest` → fails before our specs run because the sandbox does not expose direct installs of several dependencies (`zod`, `nanoid`, `@prisma/client`, Prisma scripts); Vitest exits with repeated “Failed to load url … Does the file exist?” errors.
- `pnpm vitest run apps/api/src/routes/__tests__/idempotency.test.ts apps/api/src/lib/__tests__/idempotency.test.ts` → same resolution failure (`zod` cannot be resolved), so the new tests cannot execute until the workspace exposes those packages.

Commit:
- `feat(api): add idempotency keys for job enqueue routes`

Modified files:
- `openapi.yaml`
- `apps/api/src/config/env.ts`
- `apps/api/src/lib/idempotency.ts`
- `apps/api/src/plugins/idempotency.ts`
- `apps/api/src/dev/start.ts`
- `apps/api/src/routes/exports/file.post.ts`
- `apps/api/src/routes/jobs/migrate.post.ts`
- `apps/api/src/routes/__tests__/idempotency.test.ts`
- `apps/api/src/lib/__tests__/idempotency.test.ts`

Git status:
- Working tree clean for tracked files; pre-existing untracked artifacts (Jackett binaries and various `codex/LOGS`/`codex/TASKS` files) remain untouched.
