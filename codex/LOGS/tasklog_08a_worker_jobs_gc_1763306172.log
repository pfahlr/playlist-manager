OpenAI Codex v0.58.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5.1-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a8d3c-f326-7d40-8733-dd3da8575457
--------
user
Implement the functionality described in codex/TASKS/08a_worker_jobs_gc.yaml, then verify with any available tests.
ERROR: MCP client for `arxiv-mcp-server-gpt` failed to start: handshaking with MCP server failed: connection closed: initialize response

thinking
**Checking for conflicting instructions**
exec
bash -lc ls in /var/home/rick/Development/playlist-manager succeeded in 95ms:
AGENTS.md
apps
codex
codex.toml
docker-compose.yml
docs
dredd.server.yml
dredd.yml
env.json
Jackett
Jackett.Binaries.LinuxAMDx64.tar.gz
node_modules
openapi.dredd.yaml
openapi.yaml
package.json
packages
pnpm-lock.yaml
pnpm-workspace.yaml
README.md
schemas

thinking
**Reviewing task instructions**
exec
bash -lc 'cat codex/TASKS/08a_worker_jobs_gc.yaml' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
id: 08a_worker_jobs_gc
title: BullMQ jobs (migrate/export stub) + snapshot GC worker
branch: codex/08a_worker_jobs_gc
overview: >
  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
acceptance:
  - Tests in codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts pass:
    * inserts with snapshot_* are cleared when normalized matches or TTL expired.
artifacts_to_touch:
  - apps/worker/src/queues/index.ts
  - apps/worker/src/jobs/snapshotGc.ts
  - apps/worker/src/config.ts
tests:
  path: codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts
  content: |
    import { prisma } from '../../../../packages/db/src/client';
    import { runGcOnce } from '../../../../apps/worker/src/jobs/snapshotGc';
    import { expect, test } from 'vitest';
    test('gc nulls matching snapshots', async () => {
      // seed minimal rows; call runGcOnce(); assert snapshots are null

thinking
**Opening test file**
exec
bash -lc "sed -n '1,200p' codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts" in /var/home/rick/Development/playlist-manager exited 2 in 52ms:
sed: can't read codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts: No such file or directory

thinking
**Verifying file path details**
exec
bash -lc 'ls codex' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
code
LOGS
support
TASKS

thinking
**Listing code snippet**
exec
bash -lc 'ls codex/code' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
codex
exec
bash -lc 'ls codex/code/codex' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
02a_prisma_init
02b_raw_migrations
03a_dbpkg_singleton
04a_api_validation_wiring
05a_pif_validator
05b_file_exporters
06a_provider_interfaces
06b_spotify_impl
06c_deezer_impl
06d_tidal_impl
06e_youtube_impl
06f_provider_factory_tests
07a_routes_playlist_items_effective
07b_route_exports_file

thinking
**Checking for missing task files**
exec
bash -lc 'ls codex/support' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
nock.ts
supertest.ts

thinking
**Investigating test setup and repo structure**
exec
bash -lc 'ls apps/worker' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
src

thinking
**Listing src directory**
exec
bash -lc 'ls apps/worker/src' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
lib
providers

thinking
**Checking for libraries**
exec
bash -lc 'ls apps/worker/src/lib' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
progress.ts
__tests__

thinking
**Listing test folders**
exec
bash -lc 'ls apps/worker/src/lib/__tests__' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
progress.test.ts

thinking
**Checking worker provider structure**
exec
bash -lc 'ls apps/worker/src/providers' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
config.ts
index.ts

thinking
**Checking configuration details**
exec
bash -lc "sed -n '1,200p' apps/worker/src/providers/config.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
import type { ProviderName } from '@app/contracts';

export type ProviderFlags = Record<ProviderName, boolean>;

export const providerFlags: ProviderFlags = {
  spotify: envBool(process.env.PROVIDERS_SPOTIFY ?? 'true'),
  deezer:  envBool(process.env.PROVIDERS_DEEZER  ?? 'true'),
  tidal:   envBool(process.env.PROVIDERS_TIDAL   ?? 'true'),
  youtube: envBool(process.env.PROVIDERS_YOUTUBE ?? 'true'),
};

export function assertEnabled(name: ProviderName) {
  if (!providerFlags[name]) {
    throw new Error(`Provider "${name}" is disabled by feature flag`);
  }
}

function envBool(v: string) {
  return ['1', 'true', 'yes', 'on'].includes(v.toLowerCase());
}

thinking
**Checking packages directory**
exec
bash -lc 'ls packages' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
config
contracts
db
interop
providers
utils

thinking
**Listing database client packages**
exec
bash -lc 'ls packages/db' in /var/home/rick/Development/playlist-manager succeeded in 49ms:
package.json
prisma
src
test
tsconfig.json

thinking
**Inspecting database client source**
exec
bash -lc 'ls packages/db/src' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
client.ts
encryption
healthcheck.ts
index.ts

thinking
**Opening client file**
exec
bash -lc "sed -n '1,200p' packages/db/src/client.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma?: PrismaClient;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log:
      process.env.NODE_ENV === 'development'
        ? ['query', 'warn', 'error']
        : ['error'],
  });

// Avoid creating multiple clients in dev (hot reload)
if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

thinking
**Inspecting Prisma schema directory**
exec
bash -lc 'ls packages/db/prisma' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
migrations
schema.prisma
seed-data
seed.ts

thinking
**Inspecting schema fields**
exec
bash -lc "sed -n '1,200p' packages/db/prisma/schema.prisma" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
// Prisma Client + Postgres
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ===================== Users & Accounts =====================

model User {
  id         Int      @id @default(autoincrement())
  email      String   @unique
  name       String?
  created_at DateTime @default(now()) @db.Timestamptz

  accounts  Account[]
  playlists Playlist[]

thinking
**Continuing to retrieve other models**
exec
bash -lc "sed -n '200,400p' packages/db/prisma/schema.prisma" in /var/home/rick/Development/playlist-manager succeeded in 42ms:
  @@unique([playlist_id, position])
  @@index([playlist_id])
  @@index([isrc])
  @@index([mb_recording_id])
  @@index([provider_track_id])
  @@map("playlist_item")
}

// ===================== Artist Knowledge & Follows =====================

model ArtistBio {
  id         Int      @id @default(autoincrement())
  artist_id  Int
  source     String
  summary    String?
  url        String?
  updated_at DateTime @default(now()) @db.Timestamptz

  artist Artist @relation(fields: [artist_id], references: [id], onDelete: Cascade)


thinking
**Checking for ADR-004**
exec
bash -lc 'rg -n "ADR-004" -n' in /var/home/rick/Development/playlist-manager succeeded in 141ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:282:**Checking for ADR-004**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:284:bash -lc 'rg -n "ADR-004" -n' in /var/home/rick/Development/playlist-manager
codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/TASKS/08a_worker_jobs_gc.yaml:24:  - Implement `runGcOnce()` that executes the SQL from ADR-004 (no Redis needed for unit test).

thinking
**Checking task log for instructions**
exec
bash -lc "sed -n '1,200p' codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
OpenAI Codex v0.58.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5.1-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a8d3c-f326-7d40-8733-dd3da8575457
--------
user
Implement the functionality described in codex/TASKS/08a_worker_jobs_gc.yaml, then verify with any available tests.
ERROR: MCP client for `arxiv-mcp-server-gpt` failed to start: handshaking with MCP server failed: connection closed: initialize response

thinking
**Checking for conflicting instructions**
exec
bash -lc ls in /var/home/rick/Development/playlist-manager succeeded in 95ms:
AGENTS.md

thinking
**Continuing log review**
exec
bash -lc "sed -n '200,400p' codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
exec
bash -lc "sed -n '1,200p' packages/db/src/client.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma?: PrismaClient;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log:
      process.env.NODE_ENV === 'development'
        ? ['query', 'warn', 'error']
        : ['error'],
  });

// Avoid creating multiple clients in dev (hot reload)
if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;

thinking
**Continuing to gather more context**
exec
bash -lc "sed -n '400,800p' codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log" in /var/home/rick/Development/playlist-manager succeeded in 38ms:


thinking
**Searching for ADR-004 document**
exec
bash -lc 'rg -n "ADR-004" -n | head' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:282:**Checking for ADR-004**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:284:bash -lc 'rg -n "ADR-004" -n' in /var/home/rick/Development/playlist-manager succeeded in 141ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:286:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:282:**Checking for ADR-004**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:287:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:284:bash -lc 'rg -n "ADR-004" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:289:codex/TASKS/08a_worker_jobs_gc.yaml:24:  - Implement `runGcOnce()` that executes the SQL from ADR-004 (no Redis needed for unit test).
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:348:**Searching for ADR-004 document**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:350:bash -lc 'rg -n "ADR-004" -n | head' in /var/home/rick/Development/playlist-manager

thinking
**Continuing log review**
exec
bash -lc "sed -n '800,1200p' codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log" in /var/home/rick/Development/playlist-manager succeeded in 39ms:


thinking
**Searching for ADR documents**
exec
bash -lc 'rg -l "ADR-004"' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log
codex/TASKS/08a_worker_jobs_gc.yaml

thinking
**Searching for ADR documentation**
exec
bash -lc 'ls docs' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
marketing

thinking
**Searching for architectural decision records**
exec
bash -lc 'rg -l "ADR-"' in /var/home/rick/Development/playlist-manager succeeded in 49ms:
AGENTS.md
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log
codex/LOGS/tasklog_02d_db_indexes_bench_1762386864.log
codex/TASKS/08a_worker_jobs_gc.yaml

thinking
**Searching for AGENTS instructions**
exec
bash -lc 'rg -n "ADR" AGENTS.md' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
3:This repository is **Spec-as-Source-of-Truth** (ADR-005). All work is **TDD-first**:
20:You are the CODEX Agent working in a monorepo managed under strict TDD and Spec-as-Source-of-Truth (ADR-005) rules.

thinking
**Searching for ADR-004 references**
exec
bash -lc 'rg -n "snapshot" -g"*.sql" -n' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
packages/db/prisma/migrations/20251030170000_raw_extras/migration.sql:27:-- 3) Effective view for playlist items (normalized -> snapshot fallback)
packages/db/prisma/migrations/20251030170000_raw_extras/migration.sql:33:  COALESCE(r.title, pi.snapshot_title) AS title,
packages/db/prisma/migrations/20251030170000_raw_extras/migration.sql:34:  COALESCE(na.norm_artists, pi.snapshot_artists) AS artists,
packages/db/prisma/migrations/20251030170000_raw_extras/migration.sql:35:  COALESCE(al.title, pi.snapshot_album) AS album,
packages/db/prisma/migrations/20251030162157_init/migration.sql:32:    "snapshot_hash" TEXT,
packages/db/prisma/migrations/20251030162157_init/migration.sql:128:    "snapshot_title" TEXT,
packages/db/prisma/migrations/20251030162157_init/migration.sql:129:    "snapshot_artists" TEXT,
packages/db/prisma/migrations/20251030162157_init/migration.sql:130:    "snapshot_album" TEXT,
packages/db/prisma/migrations/20251030162157_init/migration.sql:131:    "snapshot_expires_at" TIMESTAMPTZ,

thinking
**Searching for snapshot references**
exec
bash -lc 'rg -n "snapshot" -n' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
AGENTS.md:13:- **WORKER Agent** – BullMQ jobs (migrate/export; snapshot GC). Durable retries; idempotent ops.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:46:title: BullMQ jobs (migrate/export stub) + snapshot GC worker
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:52:    * inserts with snapshot_* are cleared when normalized matches or TTL expired.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:55:  - apps/worker/src/jobs/snapshotGc.ts
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:61:    import { runGcOnce } from '../../../../apps/worker/src/jobs/snapshotGc';
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:63:    test('gc nulls matching snapshots', async () => {
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:64:      // seed minimal rows; call runGcOnce(); assert snapshots are null
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:351:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:354:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:357:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:400:bash -lc 'rg -n "snapshot" -g"*.sql" -n' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:401:packages/db/prisma/migrations/20251030170000_raw_extras/migration.sql:27:-- 3) Effective view for playlist items (normalized -> snapshot fallback)
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:402:packages/db/prisma/migrations/20251030170000_raw_extras/migration.sql:33:  COALESCE(r.title, pi.snapshot_title) AS title,
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:403:packages/db/prisma/migrations/20251030170000_raw_extras/migration.sql:34:  COALESCE(na.norm_artists, pi.snapshot_artists) AS artists,
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:404:packages/db/prisma/migrations/20251030170000_raw_extras/migration.sql:35:  COALESCE(al.title, pi.snapshot_album) AS album,
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:405:packages/db/prisma/migrations/20251030162157_init/migration.sql:32:    "snapshot_hash" TEXT,
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:406:packages/db/prisma/migrations/20251030162157_init/migration.sql:128:    "snapshot_title" TEXT,

thinking
**Searching for ADR 004 details**
exec
bash -lc 'rg -n "snapshot_gc" -n' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:439:bash -lc 'rg -n "snapshot_gc" -n' in /var/home/rick/Development/playlist-manager

thinking
**Searching for GC documentation**
exec
bash -lc 'rg -n "snapshot" docs -n' in /var/home/rick/Development/playlist-manager exited 1 in 41ms:


thinking
**Investigating snapshot GC logic**
exec
bash -lc 'rg -n "snapshot_expires_at" -n' in /var/home/rick/Development/playlist-manager succeeded in 51ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:409:packages/db/prisma/migrations/20251030162157_init/migration.sql:131:    "snapshot_expires_at" TIMESTAMPTZ,
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:451:bash -lc 'rg -n "snapshot_expires_at" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:4002:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:4222:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:4535:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:4906:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:5271:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:5678:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:6063:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:6554:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:6993:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:7506:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:7981:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:8469:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:8944:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:9438:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:9921:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:10429:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:10933:+        snapshot_expires_at: null,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:11420:+        snapshot_expires_at: null,

thinking
**Searching for garbage collection tests**
exec
bash -lc 'rg -n "runGcOnce" -n' in /var/home/rick/Development/playlist-manager succeeded in 52ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:61:    import { runGcOnce } from '../../../../apps/worker/src/jobs/snapshotGc';
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:64:      // seed minimal rows; call runGcOnce(); assert snapshots are null
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:289:codex/TASKS/08a_worker_jobs_gc.yaml:24:  - Implement `runGcOnce()` that executes the SQL from ADR-004 (no Redis needed for unit test).
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:358:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:289:codex/TASKS/08a_worker_jobs_gc.yaml:24:  - Implement `runGcOnce()` that executes the SQL from ADR-004 (no Redis needed for unit test).
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:420:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:61:    import { runGcOnce } from '../../../../apps/worker/src/jobs/snapshotGc';
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:422:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:64:      // seed minimal rows; call runGcOnce(); assert snapshots are null
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:476:bash -lc 'rg -n "runGcOnce" -n' in /var/home/rick/Development/playlist-manager
codex/TASKS/08a_worker_jobs_gc.yaml:17:    import { runGcOnce } from '../../../../apps/worker/src/jobs/snapshotGc';
codex/TASKS/08a_worker_jobs_gc.yaml:20:      // seed minimal rows; call runGcOnce(); assert snapshots are null
codex/TASKS/08a_worker_jobs_gc.yaml:24:  - Implement `runGcOnce()` that executes the SQL from ADR-004 (no Redis needed for unit test).

thinking
**Searching for ADR documentation**
exec
bash -lc "sed -n '1,200p' packages/db/prisma/migrations/20251030170000_raw_extras/migration.sql" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
-- 1) Partial unique index: only one non-null ISRC per recording
CREATE UNIQUE INDEX IF NOT EXISTS uq_recording_isrc_not_null
ON "recording" ("isrc") WHERE "isrc" IS NOT NULL;

-- 2) Touch-updated_at trigger (generic)
CREATE OR REPLACE FUNCTION touch_updated_at() RETURNS trigger AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END; $$ LANGUAGE plpgsql;

-- Attach to tables that have updated_at
DO $$
DECLARE
  tbl text;
BEGIN
  FOREACH tbl IN ARRAY ARRAY[
    'playlist','recording','album','artist',
    'playlist_item','artist_bio','artist_link','artist_relation','job'
  ]

thinking
**Analyzing snapshot GC logic and worker setup**

I'm piecing together how the snapshot GC should clear `snapshot_*` fields in `playlist_item` when normalized track data exists or when TTL (`snapshot_expires_at`) is expired. It seems the clear conditions revolve around `recording_id` presence or expired TTL. I also note the worker and queue structure for running this GC job likely doesn't exist yet, so I'll need to build job files and config in `apps/worker`. I'll check related tasks and current code in `apps/worker` to follow the existing style.
exec
bash -lc "sed -n '1,200p' apps/worker/src/lib/progress.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import type { JobProgressStatus } from '@app/interop/jobs/progress';
import { publishJobCompletion, publishJobProgress } from '@app/interop/jobs/progress';

export type ProgressUpdateOptions = {
  status?: JobProgressStatus;
  message?: string | null;
  percent?: number | null;
};

export type ProgressReporterOptions = {
  throttleMs?: number;
};

export type ProgressReporter = {
  report(percent: number, options?: Omit<ProgressUpdateOptions, 'percent'>): void;
  complete(status: Extract<JobProgressStatus, 'succeeded' | 'failed'>, message?: string | null): void;
};

const DEFAULT_THROTTLE_MS = 250;


thinking
**Preparing for GC job implementation**

I’m gathering details to plan the GC job task properly since it’s complex and requires TDD with auto commits. I need to find where tests go (they're missing), understand the repo branch, and check how to run tests—probably with `vitest` via `pnpm` scripts in the root package.json—so I can write failing tests for `runGcOnce` before implementing it.
exec
bash -lc 'cat package.json' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
{
  "name": "playlist-manager",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "packageManager": "pnpm@9.12.3",
  "engines": {
    "node": ">=18.18"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "lint:api": "redocly lint openapi.yaml --extends recommended",
    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    "mock:api": "prism mock openapi.yaml",
    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",
    "contract:test": "schemathesis run openapi.yaml --checks all --hypothesis-deadline=1000",
    "prisma:generate": "pnpm -F @app/db exec prisma generate",

thinking
**Checking for worker scripts**
exec
bash -lc 'ls apps' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
api
mobile
web
worker

thinking
**Exploring worker package structure**
exec
bash -lc 'ls -a apps/worker' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
.
..
src

thinking
**Investigating project structure and test setup**
exec
bash -lc 'cat vitest.config.ts' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { defineConfig } from 'vitest/config';

const rootDir = path.dirname(fileURLToPath(import.meta.url));

export default defineConfig({
  resolve: {
    alias: {
      '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
      '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
      '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
      '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
      '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
      '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),
      '@app/providers-youtube': path.resolve(rootDir, 'packages/providers/youtube/src/index.ts'),
      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
      supertest: path.resolve(rootDir, 'codex/support/supertest.ts'),
    },

thinking
**Planning investigation into job queue and database helpers**
exec
bash -lc 'rg -n "enqueue" -n' in /var/home/rick/Development/playlist-manager succeeded in 48ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:612:bash -lc 'rg -n "enqueue" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_04b_openapi_warning_silencer_1762396211.log:177:293:      operationId: exports_enqueueFile
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:196:codex/code/codex/07b_route_exports_file/tests/exports.route.test.ts:5:import * as Jobs from '../../../../../apps/api/src/lib/jobs/enqueue';
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:522:enqueue.ts
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:527:bash -lc "sed -n '1,200p' apps/api/src/lib/jobs/enqueue.ts" in /var/home/rick/Development/playlist-manager succeeded in 56ms:
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:529: * Temporary enqueue stub for contract tests.
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:533:export async function enqueue(_payload: unknown): Promise<{ id: number }> {
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:537:  throw new Error('enqueue not wired yet (set API_FAKE_ENQUEUE=1 for contract tests)');
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:3799:     exports_enqueueFile: {
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:3955:     exports_enqueueFile: {
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:4111:     exports_enqueueFile: {
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:4275:     exports_enqueueFile: {
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:4488:     exports_enqueueFile: {
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:4679:     exports_enqueueFile: {
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:5162:     exports_enqueueFile: {
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:5498:     exports_enqueueFile: {
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:5895:     exports_enqueueFile: {
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:6288:     exports_enqueueFile: {
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:6727:     exports_enqueueFile: {
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:7142:     exports_enqueueFile: {

thinking
**Inspecting job enqueue file**
exec
bash -lc "sed -n '1,200p' apps/api/src/lib/jobs/enqueue.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/**
 * Temporary enqueue stub for contract tests.
 * When API_FAKE_ENQUEUE=1, returns a deterministic id without touching Redis/queues.
 * Replace with real BullMQ wiring in worker tasks.
 */
export async function enqueue(_payload: unknown): Promise<{ id: number }> {
  if (process.env.API_FAKE_ENQUEUE === '1') {
    return { id: 999 };
  }
  throw new Error('enqueue not wired yet (set API_FAKE_ENQUEUE=1 for contract tests)');
}

thinking
**Investigating job queue implementation**
exec
bash -lc 'rg -n "bull" pnpm-lock.yaml' in /var/home/rick/Development/playlist-manager exited 1 in 39ms:


thinking
**Searching for Bull library usage**
exec
bash -lc 'rg -n "Bull" -n' in /var/home/rick/Development/playlist-manager succeeded in 48ms:
AGENTS.md:13:- **WORKER Agent** – BullMQ jobs (migrate/export; snapshot GC). Durable retries; idempotent ops.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:46:title: BullMQ jobs (migrate/export stub) + snapshot GC worker
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:351:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:354:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:357:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:415:AGENTS.md:13:- **WORKER Agent** – BullMQ jobs (migrate/export; snapshot GC). Durable retries; idempotent ops.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:416:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:46:title: BullMQ jobs (migrate/export stub) + snapshot GC worker
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:417:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:423:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:424:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:425:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:351:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:426:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:354:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:427:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:357:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:641: * Replace with real BullMQ wiring in worker tasks.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:657:**Searching for Bull library usage**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:659:bash -lc 'rg -n "Bull" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:531: * Replace with real BullMQ wiring in worker tasks.

thinking
**Investigating worker app dependencies and config**
exec
bash -lc 'cat tsconfig.json' in /var/home/rick/Development/playlist-manager succeeded in 37ms:
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": []
}

thinking
**Checking interop package for jobs**
exec
bash -lc 'ls packages/interop' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
package.json
src
test
tsconfig.json

thinking
**Inspecting interop source folder**
exec
bash -lc 'ls packages/interop/src' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
importers
jobs

thinking
**Listing job definitions**
exec
bash -lc 'ls packages/interop/src/jobs' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
progress.ts

thinking
**Opening a file**
exec
bash -lc "sed -n '1,200p' packages/interop/src/jobs/progress.ts" in /var/home/rick/Development/playlist-manager succeeded in 45ms:
import { EventEmitter } from 'node:events';

export type JobProgressStatus = 'queued' | 'running' | 'succeeded' | 'failed';

export type JobProgressUpdate = {
  job_id: number;
  status: JobProgressStatus;
  percent?: number | null;
  message?: string | null;
  updated_at?: string | null;
};

export type JobProgressEvent =
  | { type: 'progress'; update: JobProgressUpdate }
  | { type: 'complete'; update: JobProgressUpdate };

const emitter = new EventEmitter();
emitter.setMaxListeners(0);

export function subscribeToJobProgress(jobId: number, listener: (event: JobProgressEvent) => void): () => void {

thinking
**Inspecting API app config**
Reconnecting... 1/5

thinking
**Checking BullMQ dependency and project setup**
exec
bash -lc 'ls apps/api' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
public
src

thinking
**Investigating workspace package setup**
exec
bash -lc "sed -n '1,200p' apps/api/src/dev/start.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import Fastify from 'fastify';
import fastifyStatic from '@fastify/static';
import path from 'node:path';
import docsRoutes from '../routes/docs.js'; // ensure .ts resolves via tsx; .js is ok too
import authProviders from '../routes/auth.providers.js';
import { registerRouteHandlers } from '../routes/register-handlers.js';
import logging from '../plugins/logging.js';
import metrics from '../plugins/metrics.js';
import featureGuard from '../plugins/feature-guard.js';
import errorsPlugin from '../plugins/errors.js';
import jobEvents from '../routes/jobs.events.js';
import importsFile from '../routes/imports.file.js';

const app = Fastify({ logger: true });

await app.register(fastifyStatic, {
  root: path.join(process.cwd(), 'apps/api/public'),
  prefix: '/',
});


thinking
**Planning BullMQ integration and GC tests**

I'm sorting out the BullMQ setup needed for the worker app, which isn’t fully built yet. I’m reviewing the task instructions and existing repo structure to plan adding configs, repeatable jobs, and tests for snapshot garbage collection. I also need to figure out the database setup for testing, since Prisma typically requires Postgres, and see if there’s a mock or lightweight alternative in the repo to avoid test failures.
exec
bash -lc 'ls packages/db/test' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
explain_scripts.test.ts
healthcheck.cli.test.ts
indexes.test.ts
seed.test.ts
token-rotation.test.ts

thinking
**Reviewing database test handling**
exec
bash -lc "sed -n '1,200p' packages/db/test/seed.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import { beforeEach, afterAll, expect, test } from 'vitest';
import { prisma } from '../src/client';
import { runSeed } from '../prisma/seed';

async function resetDatabase() {
  await prisma.$executeRawUnsafe(`
    TRUNCATE TABLE
      playlist_item,
      provider_track_map,
      provider_playlist_map,
      recording_artist,
      recording,
      album,
      artist_relation,
      artist_link,
      artist_bio,
      artist_follow,
      playlist,
      active_playlist,
      job,

thinking
**Investigating database configuration**
exec
bash -lc 'cat env.json' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
{
"PROVIDERS_SPOTIFY":"true",
"PROVIDERS_DEEZER":"true",
"PROVIDERS_TIDAL":"true",
"PROVIDERS_YOUTUBE":"true",
"PROVIDERS_AMAZON":"false",
}

thinking
**Searching for DATABASE_URL reference**
exec
bash -lc 'rg -n "DATABASE_URL" -n' in /var/home/rick/Development/playlist-manager succeeded in 58ms:
README.md:23:With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:238:  url      = env("DATABASE_URL")
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:832:**Searching for DATABASE_URL reference**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:834:bash -lc 'rg -n "DATABASE_URL" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:923:  url      = env("DATABASE_URL")
packages/utils/src/env.ts:4:  DATABASE_URL: z.string().url(),
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:1934:I'm figuring out how to avoid Prisma instantiating errors in tests due to missing `DATABASE_URL` by dynamically importing the module after setting a dummy environment variable. This involves removing static imports of `runHealthcheck` so I can set `process.env.DATABASE_URL` before importing the module, ensuring Prisma doesn't fail on instantiation in the test environment. I'll restructure the test file with async dynamic imports and keep type-only imports to satisfy TypeScript.
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:1942:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2029:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2146:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2288:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2432:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2576:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2701:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2828:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2970:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:3112:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:3256:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:3313:+      DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr?schema=public
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:3351:-          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr

thinking
**Opening env.ts file**
exec
bash -lc "sed -n '1,200p' packages/utils/src/env.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import { z } from 'zod';

const EnvSchema = z.object({
  DATABASE_URL: z.string().url(),
  JWT_SECRET: z.string().min(32),
  PORT: z.coerce.number().default(3101),
});

export const env = EnvSchema.parse(process.env);

thinking
**Searching for database URL defaults**
exec
bash -lc "rg -n \"DATABASE_URL \\?\\?=\" -n" in /var/home/rick/Development/playlist-manager succeeded in 50ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:842:codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:1942:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:843:codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2029:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:844:codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2146:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:845:codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2288:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:846:codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2432:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:847:codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2576:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:848:codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2701:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:849:codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2828:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:850:codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2970:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:851:codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:3112:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:852:codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:3256:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:391:  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:1942:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2029:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2146:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2288:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2432:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2576:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2701:+  process.env.DATABASE_URL ??=
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2828:+  process.env.DATABASE_URL ??=

thinking
**Inspecting test file for patterns**
exec
bash -lc "sed -n '1,200p' packages/db/test/healthcheck.cli.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import { describe, expect, test, vi } from 'vitest';
import type { DbHealthcheckResult } from '../src/healthcheck';

async function loadRunHealthcheck() {
  process.env.DATABASE_URL ??=
    'postgresql://placeholder:placeholder@localhost:5432/placeholder';
  const module = await import('../src/healthcheck');
  return module.runHealthcheck;
}

describe('runHealthcheck CLI helper', () => {
  test('exits with 0 and logs success when healthy', async () => {
    const runHealthcheck = await loadRunHealthcheck();
    const exit = vi.fn();
    const info = vi.fn();
    const error = vi.fn();

    await runHealthcheck({
      check: async (): Promise<DbHealthcheckResult> => ({ ok: true }),
      logger: { info, error },

thinking
**Investigating database setup for tests**
exec
bash -lc 'cat docker-compose.yml' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
version: '3.8'
services:
  db:
    image: postgres:16
    container_name: plmgr-db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: playlistmgr
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d playlistmgr"]
      interval: 5s
      timeout: 5s
      retries: 10
  redis:
    image: redis:7

thinking
**Inspecting database test setup**
exec
bash -lc "sed -n '1,200p' packages/db/test/indexes.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import { afterAll, describe, expect, test } from 'vitest';
import { prisma } from '../src/client';

async function fetchIndexMap(table: string) {
  const rows = await prisma.$queryRaw<
    Array<{ indexname: string; indexdef: string }>
  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
}

afterAll(async () => {
  await prisma.$disconnect();
});

describe('hot-path indexes', () => {
  test('playlist lookups use user scope index', async () => {
    const indexes = await fetchIndexMap('playlist');
    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
  });


thinking
**Verifying database connection for tests**
exec
bash -lc 'echo $DATABASE_URL' in /var/home/rick/Development/playlist-manager succeeded in 38ms:


thinking
**Investigating database environment setup**
exec
bash -lc 'ls -a' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
.
..
AGENTS.md
apps
codex
codex.toml
docker-compose.yml
docs
dredd.server.yml
dredd.yml
.env
.env.example
env.json
.git
.github
.gitignore
Jackett
Jackett.Binaries.LinuxAMDx64.tar.gz
node_modules
.npmrc

thinking
**Inspecting .env for DATABASE_URL**
exec
bash -lc 'cat .env' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
PROVIDERS_SPOTIFY=true
PROVIDERS_DEEZER=true
PROVIDERS_TIDAL=true
PROVIDERS_YOUTUBE=true
# PROVIDERS_AMAZON=false   # (kept out of factory for now)

thinking
**Checking for environment examples**
exec
bash -lc 'cat .env.example' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
# Postgres (Prisma reads from DATABASE_URL)
DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_dev?schema=public"

# Shadow DB for Prisma Migrate (recommended)
SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"

# libsodium sealed secret (base64 32 byte seed)
MASTER_KEY="replace-with-base64-secret"

# Provider feature flags
PROVIDERS_SPOTIFY_ENABLED="true"
PROVIDERS_DEEZER_ENABLED="false"
PROVIDERS_TIDAL_ENABLED="false"
PROVIDERS_YOUTUBE_ENABLED="false"

thinking
**Analyzing database setup for tests**
exec
bash -lc 'ls scripts' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
check-breaking.mjs
db
dev
explain
rotate-token-key.ts
schemathesis.mjs
wait

thinking
**Checking scripts/db directory**
exec
bash -lc 'ls scripts/db' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
down.ts
up.ts

thinking
**Outlining GC implementation plan**
exec
bash -lc 'rg -n "ADR-004" codex/LOGS -n' in /var/home/rick/Development/playlist-manager succeeded in 46ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:282:**Checking for ADR-004**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:284:bash -lc 'rg -n "ADR-004" -n' in /var/home/rick/Development/playlist-manager succeeded in 141ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:286:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:282:**Checking for ADR-004**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:287:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:284:bash -lc 'rg -n "ADR-004" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:289:codex/TASKS/08a_worker_jobs_gc.yaml:24:  - Implement `runGcOnce()` that executes the SQL from ADR-004 (no Redis needed for unit test).
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:348:**Searching for ADR-004 document**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:350:bash -lc 'rg -n "ADR-004" -n | head' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:351:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:352:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:282:**Checking for ADR-004**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:353:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:284:bash -lc 'rg -n "ADR-004" -n' in /var/home/rick/Development/playlist-manager succeeded in 141ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:354:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:355:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:286:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:282:**Checking for ADR-004**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:356:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:287:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:284:bash -lc 'rg -n "ADR-004" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:357:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:358:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:289:codex/TASKS/08a_worker_jobs_gc.yaml:24:  - Implement `runGcOnce()` that executes the SQL from ADR-004 (no Redis needed for unit test).
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:359:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:348:**Searching for ADR-004 document**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:360:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:350:bash -lc 'rg -n "ADR-004" -n | head' in /var/home/rick/Development/playlist-manager

thinking
**Searching for ADR-004 document**
exec
bash -lc 'rg -ni "adr-004"' in /var/home/rick/Development/playlist-manager succeeded in 51ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:282:**Checking for ADR-004**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:284:bash -lc 'rg -n "ADR-004" -n' in /var/home/rick/Development/playlist-manager succeeded in 141ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:286:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:282:**Checking for ADR-004**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:287:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:284:bash -lc 'rg -n "ADR-004" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:289:codex/TASKS/08a_worker_jobs_gc.yaml:24:  - Implement `runGcOnce()` that executes the SQL from ADR-004 (no Redis needed for unit test).
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:348:**Searching for ADR-004 document**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:350:bash -lc 'rg -n "ADR-004" -n | head' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:351:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:352:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:282:**Checking for ADR-004**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:353:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:284:bash -lc 'rg -n "ADR-004" -n' in /var/home/rick/Development/playlist-manager succeeded in 141ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:354:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:355:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:286:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:282:**Checking for ADR-004**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:356:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:287:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:284:bash -lc 'rg -n "ADR-004" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:357:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:358:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:289:codex/TASKS/08a_worker_jobs_gc.yaml:24:  - Implement `runGcOnce()` that executes the SQL from ADR-004 (no Redis needed for unit test).
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:359:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:348:**Searching for ADR-004 document**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:360:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:350:bash -lc 'rg -n "ADR-004" -n | head' in /var/home/rick/Development/playlist-manager

thinking
**Searching logs for snapshot TTL**
exec
bash -lc 'rg -n "snapshot" codex/TASKS -n' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
codex/TASKS/07b_route_exports_file.yaml:9:    * valid payload → enqueues a job with payload snapshot; returns 202 JobRef
codex/TASKS/08a_worker_jobs_gc.yaml:2:title: BullMQ jobs (migrate/export stub) + snapshot GC worker
codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/TASKS/08a_worker_jobs_gc.yaml:8:    * inserts with snapshot_* are cleared when normalized matches or TTL expired.
codex/TASKS/08a_worker_jobs_gc.yaml:11:  - apps/worker/src/jobs/snapshotGc.ts
codex/TASKS/08a_worker_jobs_gc.yaml:17:    import { runGcOnce } from '../../../../apps/worker/src/jobs/snapshotGc';
codex/TASKS/08a_worker_jobs_gc.yaml:19:    test('gc nulls matching snapshots', async () => {
codex/TASKS/08a_worker_jobs_gc.yaml:20:      // seed minimal rows; call runGcOnce(); assert snapshots are null
codex/TASKS/02b_raw_migrations.yaml:10:    * SELECT from v_playlist_item_effective returns snapshot fallback when recording is absent.

thinking
**Searching for ADR and snapshot details**
exec
bash -lc 'rg -n "snapshot" README.md' in /var/home/rick/Development/playlist-manager exited 1 in 41ms:


thinking
**Planning restructuring by inspecting worker references**
exec
bash -lc 'rg -n "worker" -n | head' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:13:Implement the functionality described in codex/TASKS/08a_worker_jobs_gc.yaml, then verify with any available tests.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:44:bash -lc 'cat codex/TASKS/08a_worker_jobs_gc.yaml' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:45:id: 08a_worker_jobs_gc
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:46:title: BullMQ jobs (migrate/export stub) + snapshot GC worker
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:47:branch: codex/08a_worker_jobs_gc
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:51:  - Tests in codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts pass:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:54:  - apps/worker/src/queues/index.ts
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:55:  - apps/worker/src/jobs/snapshotGc.ts
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:56:  - apps/worker/src/config.ts
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:58:  path: codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts

thinking
**Designing garbage collection worker and queue setup**

I’m figuring out how to build a worker queue using BullMQ to schedule a snapshot garbage collection job at 3 AM UTC, including creating the `runGcOnce` job that clears certain playlist snapshot fields in the database using raw SQL. I’m also planning how to write TDD-style tests that seed the database properly, manage environment variables like `DATABASE_URL`, and consider dependency constraints because network access is restricted, which may affect installing BullMQ if it’s not already present.
exec
bash -lc 'rg -n "bullmq" pnpm-lock.yaml' in /var/home/rick/Development/playlist-manager exited 1 in 39ms:


thinking
**Evaluating BullMQ dependency challenges**
exec
bash -lc 'ls node_modules/.pnpm | grep bull' in /var/home/rick/Development/playlist-manager exited 1 in 40ms:


thinking
**Evaluating BullMQ installation options**
Plan update
  → Add tests for snapshot GC job covering normalized match and TTL expiration cases
  • Implement snapshot GC job logic (runGcOnce SQL) to satisfy tests
  • Wire worker queue/config for snapshot GC scheduling via BullMQ
  • Run the relevant test suite and finalize changes

thinking
**Creating detailed test strategy and setup**

I'm planning a thorough test suite for the GC job in a new file, juggling environment variable setup challenges and choosing to rely on the user setting `DATABASE_URL` externally. I'll prepare multiple tests covering snapshot cleanup with normalized data and TTL expiration, implement DB reset hooks between tests, manage Prisma connections properly, and set up necessary directories with shell commands to keep things neat and consistent.
exec
bash -lc 'mkdir -p codex/code/codex/08a_worker_jobs_gc/tests' in /var/home/rick/Development/playlist-manager succeeded in 38ms:


thinking
**Preparing test file with database setup**

I'm organizing the test file to import needed modules from vitest and project paths using calculated relative imports. I'll write helper functions to create unique users and playlists for consistent test data. Then I'll assemble test cases around `runGcOnce` covering clearing stale snapshot data, handling TTL expirations, and preserving active snapshots, making sure to reset the database before each test and disconnect Prisma afterward.
exec
bash -lc "cat <<'EOF' > codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts
import { afterAll, beforeEach, describe, expect, test } from 'vitest';

import { prisma } from '../../../../../packages/db/src/client';
import { runGcOnce } from '../../../../../apps/worker/src/jobs/snapshotGc';

async function resetDatabase() {
  await prisma."'$executeRawUnsafe(`
    TRUNCATE TABLE
      playlist_item,
      provider_track_map,
      provider_playlist_map,
      recording_artist,
      recording,
      album,
      artist_relation,
      artist_link,
      artist_bio,
      artist_follow,
      playlist,
      active_playlist,
      job,
      account,
      app_user
    RESTART IDENTITY CASCADE;
  `);
}

beforeEach(async () => {
  await resetDatabase();
});

afterAll(async () => {
  await prisma.$disconnect();
});

describe('"'snapshot GC job', () => {
  test('clears snapshot fields when a normalized recording is matched', async () => {
    const { playlist } = await createUserAndPlaylist();

    const recording = await prisma.recording.create({
      data: {
        title: 'Normalized Track',
      },
    });

    const item = await prisma.playlistItem.create({
      data: {
        playlist_id: playlist.id,
        position: 0,
        recording_id: recording.id,
        snapshot_title: 'Legacy Title',
        snapshot_artists: 'Legacy Artist',
        snapshot_album: 'Legacy Album',
        snapshot_expires_at: new Date(Date.now() + 60 * 60 * 1000),
      },
    });

    await runGcOnce();

    const updated = await prisma.playlistItem.findUniqueOrThrow({
      where: { id: item.id },
    });

    expect(updated.snapshot_title).toBeNull();
    expect(updated.snapshot_artists).toBeNull();
    expect(updated.snapshot_album).toBeNull();
    expect(updated.snapshot_expires_at).toBeNull();
  });

  test('clears expired snapshot fields when TTL elapses', async () => {
    const { playlist } = await createUserAndPlaylist();

    const expiredItem = await prisma.playlistItem.create({
      data: {
        playlist_id: playlist.id,
        position: 0,
        snapshot_title: 'Expired Title',
        snapshot_artists: 'Expired Artist',
        snapshot_album: 'Expired Album',
        snapshot_expires_at: new Date(Date.now() - 60 * 60 * 1000),
      },
    });

    await runGcOnce();

    const updated = await prisma.playlistItem.findUniqueOrThrow({
      where: { id: expiredItem.id },
    });

    expect(updated.snapshot_title).toBeNull();
    expect(updated.snapshot_artists).toBeNull();
    expect(updated.snapshot_album).toBeNull();
    expect(updated.snapshot_expires_at).toBeNull();
  });

  test('keeps snapshot fields when neither condition matches', async () => {
    const { playlist } = await createUserAndPlaylist();

    const activeItem = await prisma.playlistItem.create({
      data: {
        playlist_id: playlist.id,
        position: 0,
        snapshot_title: 'Active Title',
        snapshot_artists: 'Active Artist',
        snapshot_album: 'Active Album',
        snapshot_expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000),
      },
    });

    await runGcOnce();

    const updated = await prisma.playlistItem.findUniqueOrThrow({
      where: { id: activeItem.id },
    });

    expect(updated.snapshot_title).toBe('Active Title');
    expect(updated.snapshot_artists).toBe('Active Artist');
    expect(updated.snapshot_album).toBe('Active Album');
    expect(updated.snapshot_expires_at).not.toBeNull();
  });
});

async function createUserAndPlaylist() {
  const user = await prisma.user.create({
    data: {
      email: "'`worker-gc+${Math.random().toString(16).slice(2)}@local`,
    },
  });

  const playlist = await prisma.playlist.create({
    data: {
      user_id: user.id,
      name: '"'Test Playlist',
    },
  });

  return { user, playlist };
}
EOF" in /var/home/rick/Development/playlist-manager succeeded in 39ms:


thinking
**Confirming Prisma model usage and planning test stubs**

I'm making sure Prisma model and field names fit the schema conventions and planning to create a minimal stub for `runGcOnce` so tests referencing it can compile and run. I’m balancing strict TDD by initially writing minimal placeholder code that allows tests to fail meaningfully while setting up the job file in the right directory.
exec
bash -lc 'mkdir -p apps/worker/src/jobs' in /var/home/rick/Development/playlist-manager succeeded in 38ms:


thinking
**Creating snapshotGc.ts stub**
exec
bash -lc "cat <<'EOF' > apps/worker/src/jobs/snapshotGc.ts
export async function runGcOnce(): Promise<number> {
  // TODO: implement via ADR-004 SQL
  return 0;
}
EOF" in /var/home/rick/Development/playlist-manager succeeded in 39ms:


thinking
**Preparing to run targeted tests**
exec
bash -lc 'DATABASE_URL=${DATABASE_URL:-postgresql://postgres:postgres@127.0.0.1:5432/playlistmgr} pnpm vitest run codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 2.05s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager


⎯⎯⎯⎯⎯⎯ Failed Suites 1 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts [ codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts ]
Error: Failed to load url @prisma/client (resolved id: @prisma/client) in /var/home/rick/Development/playlist-manager/packages/db/src/client.ts. Does the file exist?
 ❯ loadAndTransform node_modules/vite/dist/node/chunks/dep-Bid9ssRr.js:41317:17

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/1]⎯


 Test Files  1 failed (1)
      Tests  no tests
   Start at  10:23:42
   Duration  343ms (transform 57ms, setup 0ms, collect 0ms, tests 0ms, environment 0ms, prepare 82ms)


thinking
**Investigating missing Prisma client dependency**
exec
bash -lc 'cat packages/db/package.json' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
{
  "name": "@app/db",
  "private": true,
  "type": "module",
  "scripts": {
    "prisma": "prisma",
    "prisma:generate": "prisma generate",
    "prisma:migrate:dev": "prisma migrate dev",
    "prisma:migrate:deploy": "prisma migrate deploy",
    "prisma:studio": "prisma studio"
  },
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.22.0"
  },
  "devDependencies": {
    "prisma": "^5.22.0",
    "tsx": "^4.16.0"

thinking
**Checking prisma client installation**
exec
bash -lc 'ls node_modules/.pnpm | head' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
abort-controller@3.0.0
abstract-logging@2.0.1
accepts@1.3.8
agent-base@6.0.2
agent-base@7.1.4
ajv@6.12.3
ajv@6.12.6
ajv@8.17.1
ajv-formats@2.1.1_ajv@8.17.1
ajv-formats@3.0.1_ajv@8.17.1
ls: write error: Broken pipe

thinking
**Checking for Prisma client installation**
exec
bash -lc 'ls node_modules/.pnpm | grep prisma' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
prisma@5.22.0
@prisma+client@5.22.0_prisma@5.22.0
@prisma+debug@5.22.0
@prisma+engines@5.22.0
@prisma+engines-version@5.22.0-44.605197351a3c8bdd595af2d2a9bc3025bca48ea2
@prisma+fetch-engine@5.22.0
@prisma+get-platform@5.22.0

thinking
**Investigating missing Prisma client generation**
exec
bash -lc 'DATABASE_URL=${DATABASE_URL:-postgresql://postgres:postgres@127.0.0.1:5432/playlistmgr} pnpm -F @app/db prisma:generate' in /var/home/rick/Development/playlist-manager exited 1 in 1.23s:

> @app/db@ prisma:generate /var/home/rick/Development/playlist-manager/packages/db
> prisma generate

sh: line 1: prisma: command not found
/var/home/rick/Development/playlist-manager/packages/db:
 ERR_PNPM_RECURSIVE_RUN_FIRST_FAIL  @app/db@ prisma:generate: `prisma generate`
spawn ENOENT
 WARN   Local package.json exists, but node_modules missing, did you mean to install?

thinking
**Investigating node_modules structure**
exec
bash -lc 'cat .npmrc' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
ignore-workspace-root-check=true

thinking
**Investigating pnpm install and node_modules structure**
exec
bash -lc 'pnpm install' in /var/home/rick/Development/playlist-manager exited 1 in 1m 11s:
Scope: all 9 workspace projects
 WARN  GET https://registry.npmjs.org/ajv error (EAI_AGAIN). Will retry in 10 seconds. 2 retries left.
 WARN  GET https://registry.npmjs.org/fast-xml-parser error (EAI_AGAIN). Will retry in 10 seconds. 2 retries left.
 WARN  GET https://registry.npmjs.org/typescript error (EAI_AGAIN). Will retry in 10 seconds. 2 retries left.
Progress: resolved 0, reused 1, downloaded 0, added 0
Progress: resolved 20, reused 20, downloaded 0, added 0
 WARN  GET https://registry.npmjs.org/ajv error (EAI_AGAIN). Will retry in 1 minute. 1 retries left.
 WARN  GET https://registry.npmjs.org/fast-xml-parser error (EAI_AGAIN). Will retry in 1 minute. 1 retries left.
 WARN  GET https://registry.npmjs.org/typescript error (EAI_AGAIN). Will retry in 1 minute. 1 retries left.
/var/home/rick/Development/playlist-manager/packages/interop:
 ERR_PNPM_META_FETCH_FAIL  GET https://registry.npmjs.org/ajv: request to https://registry.npmjs.org/ajv failed, reason: getaddrinfo EAI_AGAIN registry.npmjs.org

This error happened while installing a direct dependency of /var/home/rick/Development/playlist-manager/packages/interop

thinking
**Checking existing node_modules for Prisma CLI**
exec
bash -lc 'ls packages/db' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
package.json
prisma
src
test
tsconfig.json

thinking
**Checking node_modules structure in packages/db**
exec
bash -lc 'ls packages/db/node_modules' in /var/home/rick/Development/playlist-manager exited 2 in 44ms:
ls: cannot access 'packages/db/node_modules': No such file or directory

thinking
**Analyzing module resolution issue**
exec
bash -lc 'ls node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules/@prisma/client' in /var/home/rick/Development/playlist-manager exited 2 in 38ms:
ls: cannot access 'node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules/@prisma/client': No such file or directory

thinking
**Checking alternative package locations**
exec
bash -lc 'ls node_modules/.pnpm | head -n 20' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
abort-controller@3.0.0
abstract-logging@2.0.1
accepts@1.3.8
agent-base@6.0.2
agent-base@7.1.4
ajv@6.12.3
ajv@6.12.6
ajv@8.17.1
ajv-formats@2.1.1_ajv@8.17.1
ajv-formats@3.0.1_ajv@8.17.1
ansi-colors@4.1.3
ansi-escapes@4.3.2
ansi-regex@5.0.1
ansi-regex@6.2.2
ansi-styles@3.2.1
ansi-styles@4.3.0
ansi-styles@5.2.0
ansi-styles@6.2.3
anymatch@3.1.3
api-blueprint-http-formatter@0.0.1

thinking
**Searching for Prisma client imports**
exec
bash -lc "ls node_modules/.pnpm | grep '@prisma'" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
@prisma+client@5.22.0_prisma@5.22.0
@prisma+debug@5.22.0
@prisma+engines@5.22.0
@prisma+engines-version@5.22.0-44.605197351a3c8bdd595af2d2a9bc3025bca48ea2
@prisma+fetch-engine@5.22.0
@prisma+get-platform@5.22.0

thinking
**Inspecting client directory**
exec
bash -lc 'ls node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
node_modules

thinking
**Checking for symlinks inside directories**
exec
bash -lc 'ls node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules' in /var/home/rick/Development/playlist-manager succeeded in 38ms:


thinking
**Investigating empty node_modules contents**
exec
bash -lc 'ls -a node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
.
..

thinking
**Investigating missing @prisma/client package**

I'm working through why `@prisma/client` isn't showing up in `node_modules`—it might be a partial or failed `pnpm install`. Since offline network restrictions block fresh installs, I'm considering ways to use existing stores or manually copy the Prisma CLI to fix missing commands. It’s tricky because the Prisma client and CLI need proper generation, but the current environment seems incomplete or partially installed. I’m exploring symlink issues, offline installs, and possible workarounds to get Prisma tools available for running tests.
exec
bash -lc "ls node_modules/.pnpm | grep '"'^prisma@'"'" in /var/home/rick/Development/playlist-manager succeeded in 67ms:
prisma@5.22.0

thinking
**Checking prisma CLI accessibility**
exec
bash -lc 'ls node_modules/.bin | head' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
acorn
astring
astro
browserslist
bumpp
cssesc
esbuild
eslint
eslint-config
fxparser

thinking
**Examining prisma installation and symlinks**
exec
bash -lc 'pnpm install --filter @app/db --offline' in /var/home/rick/Development/playlist-manager exited 1 in 1.28s:
/var/home/rick/Development/playlist-manager/packages/db:
 ERR_PNPM_NO_OFFLINE_META  Failed to resolve prisma@5.22.0 in package mirror /home/rick/.cache/pnpm/metadata/registry.npmjs.org/prisma.json

This error happened while installing a direct dependency of /var/home/rick/Development/playlist-manager/packages/db

thinking
**Checking for prisma client files**
exec
bash -lc 'ls node_modules | grep prisma' in /var/home/rick/Development/playlist-manager exited 1 in 42ms:


thinking
**Checking node_modules structure**
exec
bash -lc 'ls node_modules | head' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
acorn
acorn-jsx
ajv
@ampproject
ansi-align
ansi-escapes
ansi-regex
ansis
ansi-styles
@antfu
ls: write error: Broken pipe

thinking
**Checking for @prisma directory**
exec
bash -lc "ls node_modules | grep '@prisma'" in /var/home/rick/Development/playlist-manager exited 1 in 39ms:


thinking
**Analyzing missing @prisma/client links**
exec
bash -lc 'find node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0 -maxdepth 3 | head -n 40' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0
node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules

thinking
**Checking for missing Prisma packages**
exec
bash -lc 'find node_modules/.pnpm/prisma@5.22.0 -maxdepth 2' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
node_modules/.pnpm/prisma@5.22.0
node_modules/.pnpm/prisma@5.22.0/node_modules

thinking
**Investigating node_modules content**
exec
bash -lc 'find node_modules/.pnpm/acorn@* -maxdepth 2 | head' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
find: ‘node_modules/.pnpm/acorn@*’: No such file or directory

thinking
**Inspecting node_modules structure**
exec
bash -lc 'ls node_modules/acorn' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
bin
CHANGELOG.md
dist
LICENSE
package.json
README.md

thinking
**Investigating missing @prisma/client package and build issues**

I’m figuring out why `@prisma/client` is missing from root `node_modules`, which breaks tests needing a real database. The `node_modules` isn’t symlinked to `.pnpm` store as expected, possibly due to an interrupted build. Without `@prisma/client`, I can’t run or verify tests, and network restrictions prevent installing it fresh. I’m exploring if the client might be vendored elsewhere, stubbed for testing, or generated using prisma CLI found somewhere in `.pnpm`, but so far the client’s missing, leaving a key roadblock.
exec
bash -lc 'find node_modules/.pnpm/prisma@5.22.0 -maxdepth 4 | head -n 40' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
node_modules/.pnpm/prisma@5.22.0
node_modules/.pnpm/prisma@5.22.0/node_modules

thinking
**Investigating pnpm package structure**

I'm puzzling through how pnpm organizes packages inside `node_modules/.pnpm`, noting some packages seem missing or empty there. I want to inspect known packages like `ajv@6.12.3` more deeply with a find command to understand where the actual files live.
exec
bash -lc 'find node_modules/.pnpm/ajv@6.12.3 -maxdepth 3 | head -n 40' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
node_modules/.pnpm/ajv@6.12.3
node_modules/.pnpm/ajv@6.12.3/node_modules

thinking
**Investigating Prisma Client package location**
exec
bash -lc 'rg -n "PrismaClientKnownRequestError" -g"*.js"' in /var/home/rick/Development/playlist-manager exited 1 in 43ms:


thinking
**Verifying Prisma client availability**
exec
bash -lc 'which prisma' in /var/home/rick/Development/playlist-manager exited 1 in 38ms:
which: no prisma in (/home/rick/.local/bin:/home/rick/bin:/tmp/.tmpoM3eWe:/var/home/rick/.bun/install/global/node_modules/@openai/codex/vendor/x86_64-unknown-linux-musl/path:/var/home/rick/binary_app_releases/google-cloud-sdk/bin:/home/rick/.bun/bin:/home/rick/bin:/usr/local/bin:/usr/local/sbin:/usr/lib64/qt-3.3/bin:/home/rick/.cargo/bin:/usr/bin:/bin:/usr/sbin:/sbin:/home/rick/bin:/home/rick/.local/bin:/home/rick/bash_scripts:/home/rick/.cargo/bin:/home/rick/.npm-packages/bin:/home/rick/go/bin)

thinking
**Investigating missing Prisma client packages**
exec
bash -lc "find . -maxdepth 4 -name '@prisma'" in /var/home/rick/Development/playlist-manager succeeded in 131ms:


thinking
**Considering directory name quoting**
exec
bash -lc "find . -maxdepth 5 -path '*@prisma*' | head" in /var/home/rick/Development/playlist-manager succeeded in 149ms:
./node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0
./node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules
./node_modules/.pnpm/@prisma+engines@5.22.0
./node_modules/.pnpm/@prisma+engines@5.22.0/node_modules
./node_modules/.pnpm/@prisma+debug@5.22.0
./node_modules/.pnpm/@prisma+debug@5.22.0/node_modules
./node_modules/.pnpm/@prisma+engines-version@5.22.0-44.605197351a3c8bdd595af2d2a9bc3025bca48ea2
./node_modules/.pnpm/@prisma+engines-version@5.22.0-44.605197351a3c8bdd595af2d2a9bc3025bca48ea2/node_modules
./node_modules/.pnpm/@prisma+get-platform@5.22.0
./node_modules/.pnpm/@prisma+get-platform@5.22.0/node_modules

thinking
**Investigating deeper .pnpm structure**
exec
bash -lc 'find node_modules/.pnpm/ajv@6.12.3 -maxdepth 4' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
node_modules/.pnpm/ajv@6.12.3
node_modules/.pnpm/ajv@6.12.3/node_modules

thinking
**Inspecting node_modules symlink**
exec
bash -lc 'ls -ld node_modules/.pnpm' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
drwxr-xr-x 1 rick rick 27814 Nov  5 23:35 node_modules/.pnpm

thinking
**Investigating unexpected directory contents**
exec
bash -lc 'ls -l node_modules/.pnpm | head' in /var/home/rick/Development/playlist-manager succeeded in 46ms:
total 0
drwxr-xr-x 1 rick rick 24 Nov  5 23:35 abort-controller@3.0.0
drwxr-xr-x 1 rick rick 24 Nov  5 23:35 abstract-logging@2.0.1
drwxr-xr-x 1 rick rick 24 Nov  5 23:35 accepts@1.3.8
drwxr-xr-x 1 rick rick 24 Nov  5 23:35 agent-base@6.0.2
drwxr-xr-x 1 rick rick 24 Nov  5 23:35 agent-base@7.1.4
drwxr-xr-x 1 rick rick 24 Nov  5 23:35 ajv@6.12.3
drwxr-xr-x 1 rick rick 24 Nov  5 23:35 ajv@6.12.6
drwxr-xr-x 1 rick rick 24 Nov  5 23:35 ajv@8.17.1
drwxr-xr-x 1 rick rick 24 Nov  5 23:35 ajv-formats@2.1.1_ajv@8.17.1
ls: write error: Broken pipe

thinking
**Investigating node_modules structure**
exec
bash -lc 'ls -l node_modules/acorn' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
total 44
drwxr-xr-x. 1 rick rick    10 Jul 28 10:00 bin
-rw-r--r--. 1 rick rick 22882 Jul 28 10:00 CHANGELOG.md
drwxr-xr-x. 1 rick rick    88 Jul 28 10:00 dist
-rw-r--r--. 1 rick rick  1099 Jul 28 10:00 LICENSE
-rw-r--r--. 1 rick rick  1061 Jul 28 10:00 package.json
-rw-r--r--. 1 rick rick 10799 Jul 28 10:00 README.md

thinking
**Investigating missing Prisma client dependency**
exec
bash -lc 'rg -n "dmmf" -g"*"' in /var/home/rick/Development/playlist-manager exited 124 in 10.06s:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1707:bash -lc 'rg -n "dmmf" -g"*"' in /var/home/rick/Development/playlist-manager

thinking
**Adjusting search parameters**
exec
bash -lc 'rg -n "dmmf" packages' in /var/home/rick/Development/playlist-manager exited 1 in 43ms:


thinking
**Investigating missing Prisma client and dependencies**
exec
bash -lc 'ls -R node_modules/.pnpm/ansi-styles@6.2.3 | head -n 40' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
node_modules/.pnpm/ansi-styles@6.2.3:
node_modules

node_modules/.pnpm/ansi-styles@6.2.3/node_modules:

thinking
**Investigating node_modules structure**
exec
bash -lc 'ls node_modules/@prisma' in /var/home/rick/Development/playlist-manager exited 2 in 38ms:
ls: cannot access 'node_modules/@prisma': No such file or directory

thinking
**Evaluating prisma dependency issues**
exec
bash -lc "rg -n '\"name\"\\s*:\\s*\"@prisma/client\"' -g'package.json' node_modules" in /var/home/rick/Development/playlist-manager exited 1 in 148ms:


thinking
**Evaluating @prisma/client testing challenges**

I'm thinking through how to handle missing `@prisma/client` dependencies that block running tests, considering creating stubs or mocks to fake Prisma in-memory, but weighing the complexity and impact on repo functionality since real DB features are expected. I’m also exploring searching for any local backups of the package and pondering if skipping tests or explaining the limitation might be necessary given environment constraints.
exec
bash -lc 'rg -n "@prisma/client" -g"*"' in /var/home/rick/Development/playlist-manager exited 124 in 2m 00s:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:202:import { PrismaClient } from '@prisma/client';
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:322:import { PrismaClient } from '@prisma/client';
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1341:Error: Failed to load url @prisma/client (resolved id: @prisma/client) in /var/home/rick/Development/playlist-manager/packages/db/src/client.ts. Does the file exist?
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1372:    "@prisma/client": "^5.22.0"
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1463:bash -lc 'ls node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules/@prisma/client' in /var/home/rick/Development/playlist-manager exited 2 in 38ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1464:ls: cannot access 'node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules/@prisma/client': No such file or directory
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1522:**Investigating missing @prisma/client package**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1524:I'm working through why `@prisma/client` isn't showing up in `node_modules`—it might be a partial or failed `pnpm install`. Since offline network restrictions block fresh installs, I'm considering ways to use existing stores or manually copy the Prisma CLI to fix missing commands. It’s tricky because the Prisma client and CLI need proper generation, but the current environment seems incomplete or partially installed. I’m exploring symlink issues, offline installs, and possible workarounds to get Prisma tools available for running tests.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1582:**Analyzing missing @prisma/client links**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1613:**Investigating missing @prisma/client package and build issues**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1615:I’m figuring out why `@prisma/client` is missing from root `node_modules`, which breaks tests needing a real database. The `node_modules` isn’t symlinked to `.pnpm` store as expected, possibly due to an interrupted build. Without `@prisma/client`, I can’t run or verify tests, and network restrictions prevent installing it fresh. I’m exploring if the client might be vendored elsewhere, stubbed for testing, or generated using prisma CLI found somewhere in `.pnpm`, but so far the client’s missing, leaving a key roadblock.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1734:bash -lc "rg -n '\"name\"\\s*:\\s*\"@prisma/client\"' -g'package.json' node_modules" in /var/home/rick/Development/playlist-manager exited 1 in 148ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1738:**Evaluating @prisma/client testing challenges**
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1740:I'm thinking through how to handle missing `@prisma/client` dependencies that block running tests, considering creating stubs or mocks to fake Prisma in-memory, but weighing the complexity and impact on repo functionality since real DB features are expected. I’m also exploring searching for any local backups of the package and pondering if skipping tests or explaining the limitation might be necessary given environment constraints.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1742:bash -lc 'rg -n "@prisma/client" -g"*"' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_07b_route_exports_file_1763303753.log:11005:- `pnpm vitest run` ❌ — pre-existing environment issues: numerous suites fail because dependencies such as `@prisma/client`, `nanoid`, and `tweetnacl` are unavailable, missing SQL fixtures under `packages/scripts/explain`, and `apps/api/src/dev/__tests__/ensure-api-dev.test.ts` cannot bind to 127.0.0.1 (`listen EPERM`). These happen before this change and prevent a full green run here.
codex/LOGS/tasklog_07b_route_exports_file_1763303753.log:11355:- `pnpm vitest run` ❌ — pre-existing environment issues: numerous suites fail because dependencies such as `@prisma/client`, `nanoid`, and `tweetnacl` are unavailable, missing SQL fixtures under `packages/scripts/explain`, and `apps/api/src/dev/__tests__/ensure-api-dev.test.ts` cannot bind to 127.0.0.1 (`listen EPERM`). These happen before this change and prevent a full green run here.
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:270:    "@prisma/client": "^5.22.0"
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:291:import { PrismaClient } from '@prisma/client';
codex/LOGS/tasklog_06e_youtube_impl_1762416891.log:19880:- `pnpm vitest run` *(fails for existing environment gaps: missing nanoid/fastify/@prisma/client/tweetnacl packages and EPERM on 127.0.0.1; no regressions from this change)*

thinking
**Planning implementation despite missing dependencies**

I see that missing modules like `@prisma/client` and `nanoid` are known environment issues affecting tests. Even though tests can’t fully run, I’ll proceed with implementing `runGcOnce` in `apps/worker/src/jobs/snapshotGc.ts`, checking the `@app/db` alias to import `prisma` properly and following the plan stepwise.
exec
bash -lc "sed -n '1,200p' packages/db/src/index.ts" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
export { prisma } from './client';
export { dbHealthcheck } from './healthcheck';


thinking
**Planning database cleanup implementation**

thinking
**Preparing to re-run command**
file update
M /var/home/rick/Development/playlist-manager/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
M apps/worker/src/jobs/snapshotGc.ts
file update:
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';

file update:
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Designing queue and config setup**

I'm mapping out the next steps: adding a config file for Redis connection and scheduling, plus implementing queue logic in the worker app. I'm also checking existing dependencies and config patterns to keep consistency and avoid unnecessary duplication. Let's explore the packages/config to see if I can reuse existing code.
exec
bash -lc 'ls packages/config/src' in /var/home/rick/Development/playlist-manager exited 2 in 38ms:
ls: cannot access 'packages/config/src': No such file or directory
file update:
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Inspecting configuration package**
exec
bash -lc 'ls packages/config' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
env.client.ts
env.server.ts
index.ts
file update:
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Opening index.ts**
exec
bash -lc "sed -n '1,200p' packages/config/index.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
// Stub for packages/config/index.ts
file update:
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Searching for environment configurations**
exec
bash -lc 'rg -n "env" apps/api/src -g"*.ts" | head' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
apps/api/src/config/env.ts:6:      required_error: 'MASTER_KEY env var is required',
apps/api/src/config/env.ts:11:export const env = EnvSchema.parse({
apps/api/src/config/env.ts:12:  MASTER_KEY: process.env.MASTER_KEY,
apps/api/src/config/flags.ts:8:    spotify: bool(process.env.PROVIDERS_SPOTIFY_ENABLED, true),
apps/api/src/config/flags.ts:9:    deezer:  bool(process.env.PROVIDERS_DEEZER_ENABLED, false),
apps/api/src/config/flags.ts:10:    tidal:   bool(process.env.PROVIDERS_TIDAL_ENABLED, false),
apps/api/src/config/flags.ts:11:    youtube: bool(process.env.PROVIDERS_YOUTUBE_ENABLED, false)
apps/api/src/plugins/logging.ts:5:  const logger = pino({ level: process.env.LOG_LEVEL ?? 'info' });
apps/api/src/routes/__tests__/auth.providers.test.ts:11:  delete process.env.PROVIDERS_SPOTIFY_ENABLED;
apps/api/src/routes/__tests__/auth.providers.test.ts:12:  delete process.env.PROVIDERS_DEEZER_ENABLED;
file update:
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Inspecting env.ts for pattern**
exec
bash -lc "sed -n '1,160p' apps/api/src/config/env.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import { z } from 'zod';

const EnvSchema = z.object({
  MASTER_KEY: z
    .string({
      required_error: 'MASTER_KEY env var is required',
    })
    .min(1),
});

export const env = EnvSchema.parse({
  MASTER_KEY: process.env.MASTER_KEY,
});
file update:
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Designing environment config with zod**

I'm planning to create an environment config like the existing one using zod, defining `WORKER_REDIS_URL` with a fallback to `REDIS_URL` and a default Redis URL string. I’m also thinking about exporting connection options for BullMQ but facing limitations because the `bullmq` package might not be installed, so I’ll need to handle potential import or type-checking issues carefully to avoid build or runtime errors.
exec
bash -lc 'ls node_modules | grep -i bull' in /var/home/rick/Development/playlist-manager exited 1 in 39ms:

file update:
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Evaluating BullMQ inclusion challenges**
exec
bash -lc 'rg -n "bullmq" -i codex/LOGS' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:46:title: BullMQ jobs (migrate/export stub) + snapshot GC worker
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:351:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:354:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:357:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:415:AGENTS.md:13:- **WORKER Agent** – BullMQ jobs (migrate/export; snapshot GC). Durable retries; idempotent ops.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:416:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:46:title: BullMQ jobs (migrate/export stub) + snapshot GC worker
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:417:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:423:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:424:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:425:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:351:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:426:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:354:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:427:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:357:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:288:codex/TASKS/08a_worker_jobs_gc.yaml:5:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:641: * Replace with real BullMQ wiring in worker tasks.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:660:AGENTS.md:13:- **WORKER Agent** – BullMQ jobs (migrate/export; snapshot GC). Durable retries; idempotent ops.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:661:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:46:title: BullMQ jobs (migrate/export stub) + snapshot GC worker
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:662:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:663:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:285:codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:49:  Create BullMQ setup, define a "snapshot-gc" repeatable job at 03:00 UTC, and implement the GC SQL from ADR-004.
file update:
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Analyzing dependency management challenges**

I'm working through the complications of adding the `bullmq` dependency without being able to run installs due to environment restrictions. I’m considering options like updating `package.json` to declare `bullmq`, creating local stubs to avoid runtime errors, and the difficulties of manually editing the large `pnpm-lock.yaml` file to reflect this new dependency while knowing tests won't fully run without installed packages. It’s a tricky balance between meeting the spec and working within offline limits.
exec
bash -lc "sed -n '1,120p' pnpm-lock.yaml" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
lockfileVersion: '9.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

importers:

  .:
    dependencies:
      '@app/interop':
        specifier: workspace:*
        version: link:packages/interop
      '@fastify/static':
        specifier: ^8.3.0
        version: 8.3.0
      fastify:
        specifier: ^5.6.1
        version: 5.6.1
      fastify-plugin:
file update:
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';



thinking
**Designing BullMQ queue module and config**

I'm outlining the queue module to set up BullMQ with a Redis connection, scheduling a repeatable snapshot-gc job at 3:00 UTC, and implementing the GC job per ADR-004. Since I can’t add BullMQ to dependencies or the lockfile due to environment constraints, I'll structure the code to dynamically import BullMQ and avoid compile errors, while defining Redis config parsing, queue creation, worker, and scheduler setup with careful TypeScript typing and comments about missing dependencies. This approach balances the need to implement the queue logic referencing BullMQ despite lacking installed dependencies.
thinking
**Implementing repeatable job scheduling and cleanup**

I'm planning to set up the snapshot-gc repeatable job with a fixed job ID to prevent duplicates and ensure the cron schedule is correct. I'll have the code check existing repeatable jobs, remove any outdated entries with the same ID but differing cron, and add the correct repeatable job if missing. The setup will include creating the queue, scheduler, and worker, with careful handling of BullMQ’s expected options and cron syntax to ensure reliable scheduling at 3:00 UTC daily.
exec
bash -lc "cat <<'EOF' > apps/worker/src/config.ts
import { z } from 'zod';

type RedisConnectionOptions = {
  host: string;
  port: number;
  username?: string;
  password?: string;
  db?: number;
  tls?: Record<string, unknown>;
};

const EnvSchema = z.object({
  WORKER_REDIS_URL: z
    .string()
    .url()
    .default('redis://127.0.0.1:6379'),
});

const parsedEnv = EnvSchema.parse({
  WORKER_REDIS_URL:
    process.env.WORKER_REDIS_URL ?? process.env.REDIS_URL ?? 'redis://127.0.0.1:6379',
});

export const workerConfig = {
  redisUrl: parsedEnv.WORKER_REDIS_URL,
  snapshotGcCron: '0 3 * * *',
} as const;

export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);

function parseRedisUrl(urlString: string): RedisConnectionOptions {
  const url = new URL(urlString);
  const options: RedisConnectionOptions = {
    host: url.hostname,
    port: url.port ? Number(url.port) : 6379,
  };

  if (url.username) {
    options.username = decodeURIComponent(url.username);
  }
  if (url.password) {
    options.password = decodeURIComponent(url.password);
  }

  if (url.pathname && url.pathname.length > 1) {
    const dbValue = Number(url.pathname.replace('/', ''));
    if ("'!Number.isNaN(dbValue)) {
      options.db = dbValue;
    }
  }

  if (url.protocol === '"'rediss:') {
    options.tls = {};
  }

  return options;
}
EOF" in /var/home/rick/Development/playlist-manager succeeded in 89ms:

file update:
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Preparing type export for Redis options**
file update
M /var/home/rick/Development/playlist-manager/apps/worker/src/config.ts
@@ -2,3 +2,3 @@
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
@@ -28,5 +28,5 @@
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M apps/worker/src/config.ts
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';

file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Preparing queue implementation**
exec
bash -lc "cat <<'EOF' > apps/worker/src/queues/index.ts
import { Queue, QueueScheduler, Worker } from 'bullmq';

import { redisConnection, workerConfig } from '../config';
import { runGcOnce, snapshotGcJobName } from '../jobs/snapshotGc';

const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
const SNAPSHOT_GC_TIMEZONE = 'UTC';

function buildConnectionOptions() {
  return {
    connection: {
      ...redisConnection,
      tls: redisConnection.tls ? { ...redisConnection.tls } : undefined,
    },
  };
}

export function createSnapshotGcQueue() {
  return new Queue(snapshotGcJobName, buildConnectionOptions());
}

export function createSnapshotGcScheduler() {
  return new QueueScheduler(snapshotGcJobName, buildConnectionOptions());
}

export function createSnapshotGcWorker() {
  return new Worker(
    snapshotGcJobName,
    async () => {
      const cleared = await runGcOnce();
      return { cleared };
    },
    buildConnectionOptions(),
  );
}

export async function ensureSnapshotGcSchedule(queue?: Queue) {
  const targetQueue = queue ?? createSnapshotGcQueue();
  const repeatJobs = await targetQueue.getRepeatableJobs();
  const cron = workerConfig.snapshotGcCron;

  for (const job of repeatJobs) {
    if (job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron "'!== cron) {
      await targetQueue.removeRepeatableByKey(job.key);
    }
  }

  const alreadyScheduled = repeatJobs.some(
    (job) => job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron === cron,
  );

  if (!alreadyScheduled) {
    await targetQueue.add(
      snapshotGcJobName,
      { reason: '"'scheduled' },
      {
        jobId: SNAPSHOT_GC_REPEAT_JOB_ID,
        repeat: {
          cron,
          tz: SNAPSHOT_GC_TIMEZONE,
        },
        removeOnComplete: 25,
        removeOnFail: 100,
      },
    );
  }

  return targetQueue;
}

export async function setupSnapshotGc() {
  const queue = createSnapshotGcQueue();
  const scheduler = createSnapshotGcScheduler();
  await scheduler.waitUntilReady();
  await ensureSnapshotGcSchedule(queue);
  const worker = createSnapshotGcWorker();
  return { queue, scheduler, worker };
}
EOF" in /var/home/rick/Development/playlist-manager exited 1 in 38ms:
bash: line 1: apps/worker/src/queues/index.ts: No such file or directory
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Creating missing directory**
exec
bash -lc 'mkdir -p apps/worker/src/queues' in /var/home/rick/Development/playlist-manager succeeded in 90ms:

file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Creating new file**
exec
bash -lc "cat <<'EOF' > apps/worker/src/queues/index.ts
import { Queue, QueueScheduler, Worker } from 'bullmq';

import { redisConnection, workerConfig } from '../config';
import { runGcOnce, snapshotGcJobName } from '../jobs/snapshotGc';

const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
const SNAPSHOT_GC_TIMEZONE = 'UTC';

function buildConnectionOptions() {
  return {
    connection: {
      ...redisConnection,
      tls: redisConnection.tls ? { ...redisConnection.tls } : undefined,
    },
  };
}

export function createSnapshotGcQueue() {
  return new Queue(snapshotGcJobName, buildConnectionOptions());
}

export function createSnapshotGcScheduler() {
  return new QueueScheduler(snapshotGcJobName, buildConnectionOptions());
}

export function createSnapshotGcWorker() {
  return new Worker(
    snapshotGcJobName,
    async () => {
      const cleared = await runGcOnce();
      return { cleared };
    },
    buildConnectionOptions(),
  );
}

export async function ensureSnapshotGcSchedule(queue?: Queue) {
  const targetQueue = queue ?? createSnapshotGcQueue();
  const repeatJobs = await targetQueue.getRepeatableJobs();
  const cron = workerConfig.snapshotGcCron;

  for (const job of repeatJobs) {
    if (job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron "'!== cron) {
      await targetQueue.removeRepeatableByKey(job.key);
    }
  }

  const alreadyScheduled = repeatJobs.some(
    (job) => job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron === cron,
  );

  if (!alreadyScheduled) {
    await targetQueue.add(
      snapshotGcJobName,
      { reason: '"'scheduled' },
      {
        jobId: SNAPSHOT_GC_REPEAT_JOB_ID,
        repeat: {
          cron,
          tz: SNAPSHOT_GC_TIMEZONE,
        },
        removeOnComplete: 25,
        removeOnFail: 100,
      },
    );
  }

  return targetQueue;
}

export async function setupSnapshotGc() {
  const queue = createSnapshotGcQueue();
  const scheduler = createSnapshotGcScheduler();
  await scheduler.waitUntilReady();
  await ensureSnapshotGcSchedule(queue);
  const worker = createSnapshotGcWorker();
  return { queue, scheduler, worker };
}
EOF" in /var/home/rick/Development/playlist-manager succeeded in 38ms:

file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Handling BullMQ dependencies and package updates**
exec
bash -lc 'rg -n "bullmq" pnpm-lock.yaml' in /var/home/rick/Development/playlist-manager exited 1 in 39ms:

file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Evaluating dependency and build challenges**

I'm weighing how to handle the missing `bullmq` dependency since offline constraints block installing it or updating the lockfile. I'm considering keeping the `bullmq` import with a note about this in the summary, possibly adding type stubs to avoid TypeScript errors, and proceeding without actually bundling the package. I'll also prepare to rerun tests despite known failures due to missing other dependencies like `@prisma/client`.
Plan update
  ✓ Add tests for snapshot GC job covering normalized match and TTL expiration cases
  ✓ Implement snapshot GC job logic (runGcOnce SQL) to satisfy tests
  ✓ Wire worker queue/config for snapshot GC scheduling via BullMQ
  → Run the relevant test suite and finalize changes
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Running tests with expected failure**
exec
bash -lc 'DATABASE_URL=${DATABASE_URL:-postgresql://postgres:postgres@127.0.0.1:5432/playlistmgr} pnpm vitest run codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 1.97s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager


⎯⎯⎯⎯⎯⎯ Failed Suites 1 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts [ codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts ]
Error: Failed to load url @prisma/client (resolved id: @prisma/client) in /var/home/rick/Development/playlist-manager/packages/db/src/client.ts. Does the file exist?
 ❯ loadAndTransform node_modules/vite/dist/node/chunks/dep-Bid9ssRr.js:41317:17

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/1]⎯


 Test Files  1 failed (1)
      Tests  no tests
   Start at  10:36:04
   Duration  335ms (transform 53ms, setup 0ms, collect 0ms, tests 0ms, environment 0ms, prepare 70ms)

file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Marking test failure due to missing dependency**
Plan update
Attempted to run the new snapshot GC tests, but Vitest exits immediately because @prisma/client is not installed in this environment. This is the same pre-existing dependency gap noted in earlier task logs.
  ✓ Add tests for snapshot GC job covering normalized match and TTL expiration cases
  ✓ Implement snapshot GC job logic (runGcOnce SQL) to satisfy tests
  ✓ Wire worker queue/config for snapshot GC scheduling via BullMQ
  ✓ Run the relevant test suite and finalize changes
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Checking git status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
## main...origin/main [ahead 15]
?? Jackett.Binaries.LinuxAMDx64.tar.gz
?? Jackett/
?? apps/worker/src/config.ts
?? apps/worker/src/jobs/
?? apps/worker/src/queues/
?? codex/LOGS/codex_run_2025-11-16_08-49-16.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log.done
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log.done
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log.done
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log.done
?? codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log
?? codex/TASKS/q
?? codex/TASKS/work_list
?? codex/code/codex/08a_worker_jobs_gc/
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Filtering relevant untracked files**
exec
bash -lc "sed -n '1,200p' apps/worker/src/jobs/snapshotGc.ts" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
import { prisma } from '@app/db';

const SNAPSHOT_GC_SQL = `
  UPDATE playlist_item
  SET
    snapshot_title = NULL,
    snapshot_artists = NULL,
    snapshot_album = NULL,
    snapshot_expires_at = NULL
  WHERE
    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
    AND (
      recording_id IS NOT NULL
      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
    );
`;

export async function runGcOnce(): Promise<number> {
  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
  return typeof cleared === 'number' ? cleared : 0;
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..5c45b9c02fb313dbe42e871032df62f631c672ee
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,23 @@
+import { prisma } from '@app/db';
+
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Adding comment referencing ADR**
file update
M /var/home/rick/Development/playlist-manager/apps/worker/src/jobs/snapshotGc.ts
@@ -2,2 +2,3 @@
 
+// Mirror of ADR-004 snapshot cleanup query.
 const SNAPSHOT_GC_SQL = `
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M apps/worker/src/jobs/snapshotGc.ts
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';

file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';


thinking
**Adding SnapshotGcRuntime type**
file update
M /var/home/rick/Development/playlist-manager/apps/worker/src/queues/index.ts
@@ -8,2 +8,8 @@
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
@@ -70,3 +76,3 @@
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M apps/worker/src/queues/index.ts
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..2923e66c6d16ba735415e907fde0b8e60ec64c71
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();

file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..2923e66c6d16ba735415e907fde0b8e60ec64c71
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Verifying queue and test setup details**
exec
bash -lc "sed -n '1,200p' codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
import { afterAll, beforeEach, describe, expect, test } from 'vitest';

import { prisma } from '../../../../../packages/db/src/client';
import { runGcOnce } from '../../../../../apps/worker/src/jobs/snapshotGc';

async function resetDatabase() {
  await prisma.$executeRawUnsafe(`
    TRUNCATE TABLE
      playlist_item,
      provider_track_map,
      provider_playlist_map,
      recording_artist,
      recording,
      album,
      artist_relation,
      artist_link,
      artist_bio,
      artist_follow,
      playlist,
      active_playlist,
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..2923e66c6d16ba735415e907fde0b8e60ec64c71
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Preparing and staging code changes**
exec
bash -lc 'git add apps/worker/src/config.ts apps/worker/src/jobs/snapshotGc.ts apps/worker/src/queues/index.ts codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 41ms:

file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..2923e66c6d16ba735415e907fde0b8e60ec64c71
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Verifying git staging status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
## main...origin/main [ahead 15]
A  apps/worker/src/config.ts
A  apps/worker/src/jobs/snapshotGc.ts
A  apps/worker/src/queues/index.ts
A  codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts
?? Jackett.Binaries.LinuxAMDx64.tar.gz
?? Jackett/
?? codex/LOGS/codex_run_2025-11-16_08-49-16.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log.done
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log.done
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log.done
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log.done
?? codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log
?? codex/TASKS/q
?? codex/TASKS/work_list
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..2923e66c6d16ba735415e907fde0b8e60ec64c71
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Reviewing staged file diffs**
exec
bash -lc 'git diff --staged' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
new file mode 100644
index 0000000..893462d
--- /dev/null
+++ b/apps/worker/src/config.ts
@@ -0,0 +1,57 @@
+import { z } from 'zod';
+
+export type WorkerRedisConnectionOptions = {
+  host: string;
+  port: number;
+  username?: string;
+  password?: string;
+  db?: number;
+  tls?: Record<string, unknown>;
+};
+
+const EnvSchema = z.object({
+  WORKER_REDIS_URL: z
+    .string()
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..893462d1083d28f065be1d68879b25d3de926c6d
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,9 +26,9 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
   const options: RedisConnectionOptions = {
     host: url.hostname,
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..2923e66c6d16ba735415e907fde0b8e60ec64c71
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Correcting type references in config patch**
file update
M /var/home/rick/Development/playlist-manager/apps/worker/src/config.ts
@@ -32,3 +32,3 @@
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M apps/worker/src/config.ts
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..5cc9188a32e5a2980bd302109baa838a0ec9161f
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,11 +26,11 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
     port: url.port ? Number(url.port) : 6379,
   };
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..2923e66c6d16ba735415e907fde0b8e60ec64c71
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();

file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..5cc9188a32e5a2980bd302109baa838a0ec9161f
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,11 +26,11 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
     port: url.port ? Number(url.port) : 6379,
   };
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..2923e66c6d16ba735415e907fde0b8e60ec64c71
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Restaging modified files**
exec
bash -lc 'git add apps/worker/src/config.ts' in /var/home/rick/Development/playlist-manager succeeded in 40ms:

file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..5cc9188a32e5a2980bd302109baa838a0ec9161f
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,11 +26,11 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
     port: url.port ? Number(url.port) : 6379,
   };
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..2923e66c6d16ba735415e907fde0b8e60ec64c71
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Checking current status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
## main...origin/main [ahead 15]
A  apps/worker/src/config.ts
A  apps/worker/src/jobs/snapshotGc.ts
A  apps/worker/src/queues/index.ts
A  codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts
?? Jackett.Binaries.LinuxAMDx64.tar.gz
?? Jackett/
?? codex/LOGS/codex_run_2025-11-16_08-49-16.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log.done
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log.done
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log.done
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log.done
?? codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log
?? codex/TASKS/q
?? codex/TASKS/work_list
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..5cc9188a32e5a2980bd302109baa838a0ec9161f
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,11 +26,11 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
     port: url.port ? Number(url.port) : 6379,
   };
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..2923e66c6d16ba735415e907fde0b8e60ec64c71
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Verifying staged changes**
exec
bash -lc 'git diff --staged apps/worker/src/config.ts' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
new file mode 100644
index 0000000..5cc9188
--- /dev/null
+++ b/apps/worker/src/config.ts
@@ -0,0 +1,57 @@
+import { z } from 'zod';
+
+export type WorkerRedisConnectionOptions = {
+  host: string;
+  port: number;
+  username?: string;
+  password?: string;
+  db?: number;
+  tls?: Record<string, unknown>;
+};
+
+const EnvSchema = z.object({
+  WORKER_REDIS_URL: z
+    .string()
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..5cc9188a32e5a2980bd302109baa838a0ec9161f
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,11 +26,11 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
     port: url.port ? Number(url.port) : 6379,
   };
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..2923e66c6d16ba735415e907fde0b8e60ec64c71
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Identifying scheduling logic issue and fix**
file update
M /var/home/rick/Development/playlist-manager/apps/worker/src/queues/index.ts
@@ -46,12 +46,12 @@
   const cron = workerConfig.snapshotGcCron;
+  let alreadyScheduled = false;
 
   for (const job of repeatJobs) {
-    if (job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron !== cron) {
-      await targetQueue.removeRepeatableByKey(job.key);
+    if (job.id !== SNAPSHOT_GC_REPEAT_JOB_ID) continue;
+    if (job.cron === cron) {
+      alreadyScheduled = true;
+      continue;
     }
+    await targetQueue.removeRepeatableByKey(job.key);
   }
-
-  const alreadyScheduled = repeatJobs.some(
-    (job) => job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron === cron,
-  );
 
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M apps/worker/src/queues/index.ts
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..5cc9188a32e5a2980bd302109baa838a0ec9161f
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,11 +26,11 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
     port: url.port ? Number(url.port) : 6379,
   };
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..4662691a7efc9d7a2af2c6e96b811c4f604899f9
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -38,16 +44,16 @@
   const targetQueue = queue ?? createSnapshotGcQueue();
   const repeatJobs = await targetQueue.getRepeatableJobs();
   const cron = workerConfig.snapshotGcCron;
+  let alreadyScheduled = false;
 
   for (const job of repeatJobs) {
-    if (job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron !== cron) {
-      await targetQueue.removeRepeatableByKey(job.key);
+    if (job.id !== SNAPSHOT_GC_REPEAT_JOB_ID) continue;
+    if (job.cron === cron) {
+      alreadyScheduled = true;
+      continue;
     }
+    await targetQueue.removeRepeatableByKey(job.key);
   }
-
-  const alreadyScheduled = repeatJobs.some(
-    (job) => job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron === cron,
-  );
 
   if (!alreadyScheduled) {
     await targetQueue.add(
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();

file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..5cc9188a32e5a2980bd302109baa838a0ec9161f
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,11 +26,11 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
     port: url.port ? Number(url.port) : 6379,
   };
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..4662691a7efc9d7a2af2c6e96b811c4f604899f9
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -38,16 +44,16 @@
   const targetQueue = queue ?? createSnapshotGcQueue();
   const repeatJobs = await targetQueue.getRepeatableJobs();
   const cron = workerConfig.snapshotGcCron;
+  let alreadyScheduled = false;
 
   for (const job of repeatJobs) {
-    if (job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron !== cron) {
-      await targetQueue.removeRepeatableByKey(job.key);
+    if (job.id !== SNAPSHOT_GC_REPEAT_JOB_ID) continue;
+    if (job.cron === cron) {
+      alreadyScheduled = true;
+      continue;
     }
+    await targetQueue.removeRepeatableByKey(job.key);
   }
-
-  const alreadyScheduled = repeatJobs.some(
-    (job) => job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron === cron,
-  );
 
   if (!alreadyScheduled) {
     await targetQueue.add(
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Restaging queue file**
exec
bash -lc 'git add apps/worker/src/queues/index.ts' in /var/home/rick/Development/playlist-manager succeeded in 42ms:

file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..5cc9188a32e5a2980bd302109baa838a0ec9161f
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,11 +26,11 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
     port: url.port ? Number(url.port) : 6379,
   };
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..4662691a7efc9d7a2af2c6e96b811c4f604899f9
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -38,16 +44,16 @@
   const targetQueue = queue ?? createSnapshotGcQueue();
   const repeatJobs = await targetQueue.getRepeatableJobs();
   const cron = workerConfig.snapshotGcCron;
+  let alreadyScheduled = false;
 
   for (const job of repeatJobs) {
-    if (job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron !== cron) {
-      await targetQueue.removeRepeatableByKey(job.key);
+    if (job.id !== SNAPSHOT_GC_REPEAT_JOB_ID) continue;
+    if (job.cron === cron) {
+      alreadyScheduled = true;
+      continue;
     }
+    await targetQueue.removeRepeatableByKey(job.key);
   }
-
-  const alreadyScheduled = repeatJobs.some(
-    (job) => job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron === cron,
-  );
 
   if (!alreadyScheduled) {
     await targetQueue.add(
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Reviewing staged changes for queue file**
exec
bash -lc 'git diff --staged apps/worker/src/queues/index.ts' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
new file mode 100644
index 0000000..4662691
--- /dev/null
+++ b/apps/worker/src/queues/index.ts
@@ -0,0 +1,84 @@
+import { Queue, QueueScheduler, Worker } from 'bullmq';
+
+import { redisConnection, workerConfig } from '../config';
+import { runGcOnce, snapshotGcJobName } from '../jobs/snapshotGc';
+
+const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
+const SNAPSHOT_GC_TIMEZONE = 'UTC';
+
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..5cc9188a32e5a2980bd302109baa838a0ec9161f
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,11 +26,11 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
     port: url.port ? Number(url.port) : 6379,
   };
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..4662691a7efc9d7a2af2c6e96b811c4f604899f9
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -38,16 +44,16 @@
   const targetQueue = queue ?? createSnapshotGcQueue();
   const repeatJobs = await targetQueue.getRepeatableJobs();
   const cron = workerConfig.snapshotGcCron;
+  let alreadyScheduled = false;
 
   for (const job of repeatJobs) {
-    if (job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron !== cron) {
-      await targetQueue.removeRepeatableByKey(job.key);
+    if (job.id !== SNAPSHOT_GC_REPEAT_JOB_ID) continue;
+    if (job.cron === cron) {
+      alreadyScheduled = true;
+      continue;
     }
+    await targetQueue.removeRepeatableByKey(job.key);
   }
-
-  const alreadyScheduled = repeatJobs.some(
-    (job) => job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron === cron,
-  );
 
   if (!alreadyScheduled) {
     await targetQueue.add(
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Verifying config file changes**
exec
bash -lc 'git diff --staged' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
new file mode 100644
index 0000000..5cc9188
--- /dev/null
+++ b/apps/worker/src/config.ts
@@ -0,0 +1,57 @@
+import { z } from 'zod';
+
+export type WorkerRedisConnectionOptions = {
+  host: string;
+  port: number;
+  username?: string;
+  password?: string;
+  db?: number;
+  tls?: Record<string, unknown>;
+};
+
+const EnvSchema = z.object({
+  WORKER_REDIS_URL: z
+    .string()
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..5cc9188a32e5a2980bd302109baa838a0ec9161f
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,11 +26,11 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
     port: url.port ? Number(url.port) : 6379,
   };
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..4662691a7efc9d7a2af2c6e96b811c4f604899f9
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -38,16 +44,16 @@
   const targetQueue = queue ?? createSnapshotGcQueue();
   const repeatJobs = await targetQueue.getRepeatableJobs();
   const cron = workerConfig.snapshotGcCron;
+  let alreadyScheduled = false;
 
   for (const job of repeatJobs) {
-    if (job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron !== cron) {
-      await targetQueue.removeRepeatableByKey(job.key);
+    if (job.id !== SNAPSHOT_GC_REPEAT_JOB_ID) continue;
+    if (job.cron === cron) {
+      alreadyScheduled = true;
+      continue;
     }
+    await targetQueue.removeRepeatableByKey(job.key);
   }
-
-  const alreadyScheduled = repeatJobs.some(
-    (job) => job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron === cron,
-  );
 
   if (!alreadyScheduled) {
     await targetQueue.add(
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Reviewing implementation and commit details**
exec
bash -lc 'git commit -m "feat(worker): add snapshot GC job and schedule"' in /var/home/rick/Development/playlist-manager succeeded in 92ms:
[main 0592423] feat(worker): add snapshot GC job and schedule
 4 files changed, 303 insertions(+)
 create mode 100644 apps/worker/src/config.ts
 create mode 100644 apps/worker/src/jobs/snapshotGc.ts
 create mode 100644 apps/worker/src/queues/index.ts
 create mode 100644 codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..5cc9188a32e5a2980bd302109baa838a0ec9161f
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,11 +26,11 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
     port: url.port ? Number(url.port) : 6379,
   };
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..4662691a7efc9d7a2af2c6e96b811c4f604899f9
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -38,16 +44,16 @@
   const targetQueue = queue ?? createSnapshotGcQueue();
   const repeatJobs = await targetQueue.getRepeatableJobs();
   const cron = workerConfig.snapshotGcCron;
+  let alreadyScheduled = false;
 
   for (const job of repeatJobs) {
-    if (job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron !== cron) {
-      await targetQueue.removeRepeatableByKey(job.key);
+    if (job.id !== SNAPSHOT_GC_REPEAT_JOB_ID) continue;
+    if (job.cron === cron) {
+      alreadyScheduled = true;
+      continue;
     }
+    await targetQueue.removeRepeatableByKey(job.key);
   }
-
-  const alreadyScheduled = repeatJobs.some(
-    (job) => job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron === cron,
-  );
 
   if (!alreadyScheduled) {
     await targetQueue.add(
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Preparing to capture commit details**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
## main...origin/main [ahead 16]
?? Jackett.Binaries.LinuxAMDx64.tar.gz
?? Jackett/
?? codex/LOGS/codex_run_2025-11-16_08-49-16.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log.done
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log.done
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log.done
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log.done
?? codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log
?? codex/TASKS/q
?? codex/TASKS/work_list
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..5cc9188a32e5a2980bd302109baa838a0ec9161f
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,11 +26,11 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
     port: url.port ? Number(url.port) : 6379,
   };
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..4662691a7efc9d7a2af2c6e96b811c4f604899f9
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -38,16 +44,16 @@
   const targetQueue = queue ?? createSnapshotGcQueue();
   const repeatJobs = await targetQueue.getRepeatableJobs();
   const cron = workerConfig.snapshotGcCron;
+  let alreadyScheduled = false;
 
   for (const job of repeatJobs) {
-    if (job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron !== cron) {
-      await targetQueue.removeRepeatableByKey(job.key);
+    if (job.id !== SNAPSHOT_GC_REPEAT_JOB_ID) continue;
+    if (job.cron === cron) {
+      alreadyScheduled = true;
+      continue;
     }
+    await targetQueue.removeRepeatableByKey(job.key);
   }
-
-  const alreadyScheduled = repeatJobs.some(
-    (job) => job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron === cron,
-  );
 
   if (!alreadyScheduled) {
     await targetQueue.add(
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Checking remaining untracked files**
exec
bash -lc 'git log -1 --stat' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
commit 059242311c8de6c399491a26329d2d788c867547
Author: Rick Pfahl <pfahlr@gmail.com>
Date:   Sun Nov 16 10:38:06 2025 -0500

    feat(worker): add snapshot GC job and schedule

 apps/worker/src/config.ts                          |  57 +++++++++
 apps/worker/src/jobs/snapshotGc.ts                 |  24 ++++
 apps/worker/src/queues/index.ts                    |  84 +++++++++++++
 .../code/codex/08a_worker_jobs_gc/tests/gc.test.ts | 138 +++++++++++++++++++++
 4 files changed, 303 insertions(+)
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..5cc9188a32e5a2980bd302109baa838a0ec9161f
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,11 +26,11 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
     port: url.port ? Number(url.port) : 6379,
   };
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..4662691a7efc9d7a2af2c6e96b811c4f604899f9
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -38,16 +44,16 @@
   const targetQueue = queue ?? createSnapshotGcQueue();
   const repeatJobs = await targetQueue.getRepeatableJobs();
   const cron = workerConfig.snapshotGcCron;
+  let alreadyScheduled = false;
 
   for (const job of repeatJobs) {
-    if (job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron !== cron) {
-      await targetQueue.removeRepeatableByKey(job.key);
+    if (job.id !== SNAPSHOT_GC_REPEAT_JOB_ID) continue;
+    if (job.cron === cron) {
+      alreadyScheduled = true;
+      continue;
     }
+    await targetQueue.removeRepeatableByKey(job.key);
   }
-
-  const alreadyScheduled = repeatJobs.some(
-    (job) => job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron === cron,
-  );
 
   if (!alreadyScheduled) {
     await targetQueue.add(
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();


thinking
**Organizing final summary details**
codex
Implemented the worker snapshot cleanup job plus queue scaffolding and coverage.

- `apps/worker/src/jobs/snapshotGc.ts:1-24` adds `runGcOnce()` which runs the ADR-004 UPDATE to null snapshot columns whenever a playlist item now has a normalized `recording_id` or its snapshot TTL has elapsed.
- `apps/worker/src/config.ts:1-57` introduces a worker config helper that parses `WORKER_REDIS_URL` (or `REDIS_URL`) with sane defaults and exposes both the URL metadata and parsed connection options plus the fixed 03:00 UTC cron string.
- `apps/worker/src/queues/index.ts:1-84` wires BullMQ queue/scheduler/worker factories around the new job, ensures a single repeatable `snapshot-gc` job registered at 03:00 UTC, and exposes `setupSnapshotGc()` for worker bootstrap.
- `codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts:1-110` adds integration-style Vitest coverage that seeds minimal rows, exercises `runGcOnce()`, and asserts snapshot fields clear for normalized matches or expired TTLs while remaining intact otherwise.

Tests:
- `pnpm vitest run codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts` *(fails immediately because `@prisma/client` is not installed in this environment; same pre-existing issue called out in earlier logs—once the dependency is restored the new tests should execute as written).*

Commit:
- `feat(worker): add snapshot GC job and schedule`

Git status:
- `## main...origin/main [ahead 16]`
- Untracked (pre-existing) items remain: `Jackett/`, `Jackett.Binaries.LinuxAMDx64.tar.gz`, several `codex/LOGS/*` files, and `codex/TASKS/{q,work_list}`.

Next steps once dependencies/network are available:
1. Install the missing runtime deps (at minimum `@prisma/client`, and ideally `bullmq` plus its peers) and rerun the Vitest target to ensure the new cases go green.
2. Hook the worker entrypoint to `setupSnapshotGc()` so the queue, scheduler, and worker spin up automatically in runtime environments.
file update:
diff --git a/apps/worker/src/config.ts b/apps/worker/src/config.ts
index c26b6487a61da2a33ac2fd04b2c7100fb5fdb10c..5cc9188a32e5a2980bd302109baa838a0ec9161f
--- a/apps/worker/src/config.ts
+++ b/apps/worker/src/config.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 
-type RedisConnectionOptions = {
+export type WorkerRedisConnectionOptions = {
   host: string;
   port: number;
   username?: string;
@@ -26,11 +26,11 @@
   snapshotGcCron: '0 3 * * *',
 } as const;
 
-export const redisConnection: RedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
+export const redisConnection: WorkerRedisConnectionOptions = parseRedisUrl(workerConfig.redisUrl);
 
-function parseRedisUrl(urlString: string): RedisConnectionOptions {
+function parseRedisUrl(urlString: string): WorkerRedisConnectionOptions {
   const url = new URL(urlString);
-  const options: RedisConnectionOptions = {
+  const options: WorkerRedisConnectionOptions = {
     host: url.hostname,
     port: url.port ? Number(url.port) : 6379,
   };
diff --git a/apps/worker/src/jobs/snapshotGc.ts b/apps/worker/src/jobs/snapshotGc.ts
index b198b9a755f844e90d97a48d0975504bdaacec17..4e15c3d1e0a9b31316162268883cfe441b712061
--- a/apps/worker/src/jobs/snapshotGc.ts
+++ b/apps/worker/src/jobs/snapshotGc.ts
@@ -1,4 +1,24 @@
+import { prisma } from '@app/db';
+
+// Mirror of ADR-004 snapshot cleanup query.
+const SNAPSHOT_GC_SQL = `
+  UPDATE playlist_item
+  SET
+    snapshot_title = NULL,
+    snapshot_artists = NULL,
+    snapshot_album = NULL,
+    snapshot_expires_at = NULL
+  WHERE
+    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
+    AND (
+      recording_id IS NOT NULL
+      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
+    );
+`;
+
 export async function runGcOnce(): Promise<number> {
-  // TODO: implement via ADR-004 SQL
-  return 0;
+  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);
+  return typeof cleared === 'number' ? cleared : 0;
 }
+
+export const snapshotGcJobName = 'snapshot-gc';
diff --git a/apps/worker/src/queues/index.ts b/apps/worker/src/queues/index.ts
index 43ac78d9e8da43e99107f087eea722adaf1e0915..4662691a7efc9d7a2af2c6e96b811c4f604899f9
--- a/apps/worker/src/queues/index.ts
+++ b/apps/worker/src/queues/index.ts
@@ -6,6 +6,12 @@
 const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
 const SNAPSHOT_GC_TIMEZONE = 'UTC';
 
+export type SnapshotGcRuntime = {
+  queue: Queue;
+  scheduler: QueueScheduler;
+  worker: Worker;
+};
+
 function buildConnectionOptions() {
   return {
     connection: {
@@ -38,16 +44,16 @@
   const targetQueue = queue ?? createSnapshotGcQueue();
   const repeatJobs = await targetQueue.getRepeatableJobs();
   const cron = workerConfig.snapshotGcCron;
+  let alreadyScheduled = false;
 
   for (const job of repeatJobs) {
-    if (job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron !== cron) {
-      await targetQueue.removeRepeatableByKey(job.key);
+    if (job.id !== SNAPSHOT_GC_REPEAT_JOB_ID) continue;
+    if (job.cron === cron) {
+      alreadyScheduled = true;
+      continue;
     }
+    await targetQueue.removeRepeatableByKey(job.key);
   }
-
-  const alreadyScheduled = repeatJobs.some(
-    (job) => job.id === SNAPSHOT_GC_REPEAT_JOB_ID && job.cron === cron,
-  );
 
   if (!alreadyScheduled) {
     await targetQueue.add(
@@ -68,7 +74,7 @@
   return targetQueue;
 }
 
-export async function setupSnapshotGc() {
+export async function setupSnapshotGc(): Promise<SnapshotGcRuntime> {
   const queue = createSnapshotGcQueue();
   const scheduler = createSnapshotGcScheduler();
   await scheduler.waitUntilReady();

tokens used
249,198
Implemented the worker snapshot cleanup job plus queue scaffolding and coverage.

- `apps/worker/src/jobs/snapshotGc.ts:1-24` adds `runGcOnce()` which runs the ADR-004 UPDATE to null snapshot columns whenever a playlist item now has a normalized `recording_id` or its snapshot TTL has elapsed.
- `apps/worker/src/config.ts:1-57` introduces a worker config helper that parses `WORKER_REDIS_URL` (or `REDIS_URL`) with sane defaults and exposes both the URL metadata and parsed connection options plus the fixed 03:00 UTC cron string.
- `apps/worker/src/queues/index.ts:1-84` wires BullMQ queue/scheduler/worker factories around the new job, ensures a single repeatable `snapshot-gc` job registered at 03:00 UTC, and exposes `setupSnapshotGc()` for worker bootstrap.
- `codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts:1-110` adds integration-style Vitest coverage that seeds minimal rows, exercises `runGcOnce()`, and asserts snapshot fields clear for normalized matches or expired TTLs while remaining intact otherwise.

Tests:
- `pnpm vitest run codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts` *(fails immediately because `@prisma/client` is not installed in this environment; same pre-existing issue called out in earlier logs—once the dependency is restored the new tests should execute as written).*

Commit:
- `feat(worker): add snapshot GC job and schedule`

Git status:
- `## main...origin/main [ahead 16]`
- Untracked (pre-existing) items remain: `Jackett/`, `Jackett.Binaries.LinuxAMDx64.tar.gz`, several `codex/LOGS/*` files, and `codex/TASKS/{q,work_list}`.

Next steps once dependencies/network are available:
1. Install the missing runtime deps (at minimum `@prisma/client`, and ideally `bullmq` plus its peers) and rerun the Vitest target to ensure the new cases go green.
2. Hook the worker entrypoint to `setupSnapshotGc()` so the queue, scheduler, and worker spin up automatically in runtime environments.
