import { FastifyPluginAsync } from 'fastify';
import { lookupAttemptByState, succeedAttempt, failAttempt, updateAttempt } from '../lib/auth/attempts';
import {
  exchangeCodeForToken as exchangeSpotifyCode,
  fetchSpotifyProfile,
} from '../lib/auth/providers/spotify';
import { findOrCreateUser, linkProviderAccount } from '../lib/auth/users';
import { signSession } from '../lib/auth/session';
import { isProviderEnabled } from '../config/env';

const authCallbackRoutes: FastifyPluginAsync = async (fastify) => {
  /**
   * GET /auth/callback/:provider
   * OAuth provider redirects here after user authorization
   * Exchanges code for tokens, creates/links user, and redirects back to app
   */
  fastify.get('/auth/callback/:provider', {
    schema: {
      params: {
        type: 'object',
        required: ['provider'],
        properties: {
          provider: { type: 'string', enum: ['spotify', 'deezer', 'tidal', 'youtube'] },
        },
      },
      querystring: {
        type: 'object',
        properties: {
          code: { type: 'string' },
          state: { type: 'string' },
          error: { type: 'string' },
          error_description: { type: 'string' },
        },
      },
    },
    handler: async (request, reply) => {
      const { provider } = request.params as { provider: string };
      const { code, state, error, error_description } = request.query as {
        code?: string;
        state?: string;
        error?: string;
        error_description?: string;
      };

      // Check if provider is enabled
      if (!isProviderEnabled(provider as any)) {
        return reply.status(400).send({
          type: 'about:blank',
          code: 'provider_disabled',
          message: `${provider} is not enabled`,
          details: { request_id: request.id },
        });
      }

      // Look up attempt by state parameter
      if (!state) {
        return reply.status(400).send({
          type: 'about:blank',
          code: 'missing_state',
          message: 'Missing state parameter',
          details: { request_id: request.id },
        });
      }

      const attempt = await lookupAttemptByState(state);

      if (!attempt) {
        return reply.status(404).send({
          type: 'about:blank',
          code: 'attempt_not_found',
          message: 'OAuth attempt not found or expired',
          details: { request_id: request.id },
        });
      }

      // Check if attempt is already completed or expired
      if (attempt.status !== 'pending') {
        return reply.status(400).send({
          type: 'about:blank',
          code: 'attempt_already_completed',
          message: `Attempt already ${attempt.status}`,
          details: { request_id: request.id },
        });
      }

      // Handle error from OAuth provider
      if (error) {
        await failAttempt(attempt.id, error, error_description);

        // Redirect back to app with error
        const redirectUrl = new URL(attempt.redirectUri);
        redirectUrl.searchParams.set('status', 'failed');
        redirectUrl.searchParams.set('error', error);
        if (error_description) {
          redirectUrl.searchParams.set('error_description', error_description);
        }

        return reply.redirect(302, redirectUrl.toString());
      }

      // Authorization code is required for success
      if (!code) {
        await failAttempt(attempt.id, 'missing_code', 'Authorization code not provided');

        const redirectUrl = new URL(attempt.redirectUri);
        redirectUrl.searchParams.set('status', 'failed');
        redirectUrl.searchParams.set('error', 'missing_code');

        return reply.redirect(302, redirectUrl.toString());
      }

      try {
        // Store code verifier in attempt for token exchange
        // In PKCE, the client generates code_verifier, and we stored code_challenge
        // For server-side flow, we need to generate and store the code_verifier
        // For mobile PKCE, the mobile app provides code_challenge, we need to retrieve code_verifier
        // For now, we'll use the code_challenge as verifier (this is simplified - in production,
        // the mobile app would need to send the verifier separately or we'd store it)

        // IMPORTANT: In a real implementation, the code_verifier should be:
        // 1. Generated by the mobile client
        // 2. code_challenge = base64url(sha256(code_verifier)) sent in /authorize
        // 3. code_verifier sent back somehow (possibly in a separate secure channel)

        // For this MVP, we'll use a workaround where we treat code_challenge as code_verifier
        // This works for testing but is NOT secure for production
        const codeVerifier = attempt.codeChallenge; // FIXME: This is a simplified workaround

        // Exchange code for tokens based on provider
        let accessToken: string;
        let refreshToken: string | undefined;
        let expiresIn: number;
        let providerUserId: string;
        let email: string;
        let displayName: string | null;

        switch (provider) {
          case 'spotify': {
            // Exchange authorization code for tokens
            const tokenResponse = await exchangeSpotifyCode({
              code,
              codeVerifier,
              redirectUri: attempt.redirectUri,
            });

            accessToken = tokenResponse.access_token;
            refreshToken = tokenResponse.refresh_token;
            expiresIn = tokenResponse.expires_in;

            // Fetch user profile
            const profile = await fetchSpotifyProfile(accessToken);
            providerUserId = profile.id;
            email = profile.email;
            displayName = profile.display_name;
            break;
          }

          case 'deezer':
          case 'tidal':
          case 'youtube':
            throw new Error(`${provider} OAuth not yet implemented`);

          default:
            throw new Error(`Unknown provider: ${provider}`);
        }

        // Find or create user by email
        const user = await findOrCreateUser({
          email,
          name: displayName,
        });

        // Link provider account with encrypted tokens
        await linkProviderAccount({
          userId: user.id,
          provider,
          providerUserId,
          accessToken,
          refreshToken,
          expiresIn,
        });

        // Sign JWT session token
        const sessionToken = signSession({
          userId: user.id,
          email: user.email,
          provider,
        });

        // Update attempt as succeeded with session token
        await succeedAttempt(
          attempt.id,
          user.id,
          sessionToken, // Return session JWT instead of provider access token
          refreshToken || '', // Keep refresh token for token refresh
          expiresIn
        );

        // Redirect back to mobile app with success
        const redirectUrl = new URL(attempt.redirectUri);
        redirectUrl.searchParams.set('status', 'success');

        return reply.redirect(302, redirectUrl.toString());
      } catch (err) {
        // Log error and mark attempt as failed
        fastify.log.error({ err, attemptId: attempt.id, provider }, 'OAuth callback failed');

        await failAttempt(
          attempt.id,
          'token_exchange_failed',
          err instanceof Error ? err.message : 'Unknown error'
        );

        const redirectUrl = new URL(attempt.redirectUri);
        redirectUrl.searchParams.set('status', 'failed');
        redirectUrl.searchParams.set('error', 'token_exchange_failed');

        return reply.redirect(302, redirectUrl.toString());
      }
    },
  });

  /**
   * GET /auth/providers
   * List enabled OAuth providers
   */
  fastify.get('/auth/providers', {
    schema: {
      response: {
        200: {
          type: 'object',
          required: ['data'],
          properties: {
            data: {
              type: 'array',
              items: {
                type: 'object',
                required: ['name'],
                properties: {
                  name: { type: 'string', enum: ['spotify', 'deezer', 'tidal', 'youtube'] },
                },
              },
            },
          },
        },
      },
    },
    handler: async (request, reply) => {
      const providers = [];

      if (isProviderEnabled('spotify')) providers.push({ name: 'spotify' });
      if (isProviderEnabled('deezer')) providers.push({ name: 'deezer' });
      if (isProviderEnabled('tidal')) providers.push({ name: 'tidal' });
      if (isProviderEnabled('youtube')) providers.push({ name: 'youtube' });

      return reply.send({ data: providers });
    },
  });
};

export default authCallbackRoutes;
